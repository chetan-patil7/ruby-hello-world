pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['staging', 'production'],
            description: 'Select deployment environment'
        )
        string(
            name: 'BUILD_NUMBER_TO_DEPLOY',
            defaultValue: '',
            description: 'Build number from CI pipeline to deploy (leave empty for latest)'
        )
        booleanParam(
            name: 'FORCE_TOOL_INSTALLATION',
            defaultValue: false,
            description: 'Force reinstallation of all tools (even if already installed)'
        )
        booleanParam(
            name: 'SKIP_TOOL_CHECK',
            defaultValue: false,
            description: 'Skip tool verification and installation (use only if tools are confirmed to be installed)'
        )
    }
    
    environment {
        APP_NAME = 'hello-world-app'
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_STDOUT_CALLBACK = 'yaml'
    }
    
    stages {
        stage('Initial Server Tool Verification') {
            when {
                expression { !params.SKIP_TOOL_CHECK }
            }
            steps {
                script {
                    sh '''
                        echo "🔍 INITIAL SERVER TOOL VERIFICATION"
                        echo "====================================="
                        echo "Environment: ${ENVIRONMENT}"
                        echo "Force installation: ${FORCE_TOOL_INSTALLATION}"
                        echo ""
                        
                        # Create temporary Ansible structure for tool checking
                        mkdir -p temp_ansible/{inventories,playbooks}
                        mkdir -p temp_ansible/inventories/staging
                        mkdir -p temp_ansible/inventories/production
                        
                        # Create inventory files
                        cat > temp_ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=54.210.171.180 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        cat > temp_ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        # Create comprehensive tool verification playbook with SMART skip logic
                        cat > temp_ansible/playbooks/verify_and_install_tools.yml << 'PLAYBOOK_EOF'
---
- name: Smart Tool Verification - Skip Already Installed
  hosts: webservers
  become: yes
  vars:
    force_installation: "{{ force_tool_installation | default(false) }}"
  
  tasks:
    - name: Create tool check directory with proper permissions
      file:
        path: /tmp/tool_check
        state: directory
        mode: '0777'
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"

    - name: Smart tool audit script
      copy:
        dest: /tmp/smart_audit.sh
        mode: '0755'
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        content: |
          #!/bin/bash
          echo "🔍 SMART SERVER TOOL AUDIT"
          echo "==========================="
          echo "Date: $(date)"
          echo "Server: $(hostname)"
          echo ""
          
          # Initialize tracking
          MISSING_PACKAGES=""
          INSTALL_REQUIRED=false
          
          echo "📦 SYSTEM PACKAGES AUDIT:"
          echo "========================"
          
          # Check each package individually and only mark missing ones
          for pkg in curl wget git build-essential postgresql python3 unzip; do
            if dpkg -l 2>/dev/null | grep -q "^ii.*$pkg "; then
              echo "  ✅ $pkg - installed (SKIP)"
            else
              echo "  ❌ $pkg - MISSING (WILL INSTALL)"
              MISSING_PACKAGES="$MISSING_PACKAGES $pkg"
              INSTALL_REQUIRED=true
            fi
          done
          
          # Check redis-server specifically
          if dpkg -l 2>/dev/null | grep -q "^ii.*redis-server"; then
            echo "  ✅ redis-server - installed (SKIP)"
          else
            echo "  ❌ redis-server - MISSING (WILL INSTALL)"
            MISSING_PACKAGES="$MISSING_PACKAGES redis-server"
            INSTALL_REQUIRED=true
          fi
          
          # Check imagemagick specifically
          if dpkg -l 2>/dev/null | grep -q "^ii.*imagemagick"; then
            echo "  ✅ imagemagick - installed (SKIP)"
          else
            echo "  ❌ imagemagick - MISSING (WILL INSTALL)"
            MISSING_PACKAGES="$MISSING_PACKAGES imagemagick"
            INSTALL_REQUIRED=true
          fi
          
          # Skip npm check since it's already installed via Node.js
          if command -v npm >/dev/null 2>&1; then
            echo "  ✅ npm - installed via Node.js (SKIP)"
          else
            echo "  ❌ npm - NOT FOUND"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "💎 RUBY ENVIRONMENT AUDIT:"
          echo "========================="
          
          if [ -d "/home/{{ deploy_user }}/.rbenv" ]; then
            echo "  ✅ rbenv - installed (SKIP)"
          else
            echo "  ❌ rbenv - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v ruby >/dev/null 2>&1; then
            RUBY_VERSION=$(ruby --version)
            echo "  ✅ Ruby - $RUBY_VERSION (SKIP)"
          else
            echo "  ❌ Ruby - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v bundle >/dev/null 2>&1; then
            BUNDLER_VERSION=$(bundle --version)
            echo "  ✅ Bundler - $BUNDLER_VERSION (SKIP)"
          else
            echo "  ❌ Bundler - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "🟢 NODE.JS ENVIRONMENT AUDIT:"
          echo "============================"
          
          if command -v node >/dev/null 2>&1; then
            NODE_VERSION=$(node --version)
            echo "  ✅ Node.js - $NODE_VERSION (SKIP)"
          else
            echo "  ❌ Node.js - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v npm >/dev/null 2>&1; then
            NPM_VERSION=$(npm --version)
            echo "  ✅ npm - $NPM_VERSION (SKIP)"
          else
            echo "  ❌ npm - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "🐘 POSTGRESQL AUDIT:"
          echo "==================="
          
          if command -v psql >/dev/null 2>&1; then
            PSQL_VERSION=$(psql --version)
            echo "  ✅ PostgreSQL client - $PSQL_VERSION (SKIP)"
          else
            echo "  ❌ PostgreSQL client - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if systemctl is-active postgresql >/dev/null 2>&1; then
            echo "  ✅ PostgreSQL service - RUNNING (SKIP)"
          else
            echo "  ❌ PostgreSQL service - NOT RUNNING (WILL CONFIGURE)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "📋 SMART AUDIT SUMMARY:"
          echo "======================"
          
          if [ "$INSTALL_REQUIRED" = "true" ] || [ "{{ force_installation }}" = "true" ]; then
            echo "🔧 SELECTIVE INSTALLATION REQUIRED"
            echo "Only missing packages will be installed"
            echo "Already installed packages will be SKIPPED"
            echo "INSTALL_REQUIRED" > /tmp/tool_check/status
          else
            echo "✅ ALL TOOLS ALREADY INSTALLED"
            echo "No installation needed - all tools present"
            echo "TOOLS_READY" > /tmp/tool_check/status
          fi
          
          # Store only missing packages (exclude already installed)
          echo "$MISSING_PACKAGES" > /tmp/tool_check/missing_packages
          
          echo ""
          echo "📦 Packages to install: $MISSING_PACKAGES"
          echo "💡 Installed packages will be skipped automatically"

    - name: Execute smart tool audit
      shell: /tmp/smart_audit.sh
      register: tool_audit
      become_user: "{{ deploy_user }}"

    - name: Display audit results
      debug:
        msg: "{{ tool_audit.stdout_lines }}"

    - name: Read tool status
      shell: cat /tmp/tool_check/status
      register: tool_status
      ignore_errors: yes

    - name: Read missing packages list
      shell: cat /tmp/tool_check/missing_packages
      register: missing_packages
      ignore_errors: yes

    - name: Install ONLY missing system packages
      apt:
        name: "{{ missing_packages.stdout.split() }}"
        state: present
        update_cache: yes
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - missing_packages.stdout | trim | length > 0
      ignore_errors: yes

    - name: Install redis-server separately if missing
      apt:
        name: redis-server
        state: present
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - "'redis-server' in missing_packages.stdout"
      ignore_errors: yes

    - name: Install imagemagick separately if missing
      apt:
        name: imagemagick
        state: present
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - "'imagemagick' in missing_packages.stdout"
      ignore_errors: yes

    - name: Setup Ruby environment only if needed
      shell: |
        # Check if Ruby setup is actually needed
        if [ ! -d "/home/{{ deploy_user }}/.rbenv" ] || ! command -v ruby >/dev/null 2>&1 || ! command -v bundle >/dev/null 2>&1 || [ "{{ force_installation }}" = "true" ]; then
          echo "💎 SETTING UP RUBY ENVIRONMENT..."
          
          # Install rbenv only if missing
          if [ ! -d "/home/{{ deploy_user }}/.rbenv" ]; then
            echo "Installing rbenv..."
            git clone https://github.com/rbenv/rbenv.git /home/{{ deploy_user }}/.rbenv
            git clone https://github.com/rbenv/ruby-build.git /home/{{ deploy_user }}/.rbenv/plugins/ruby-build
            
            # Add to bashrc if not present
            if ! grep -q 'rbenv' /home/{{ deploy_user }}/.bashrc; then
              echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> /home/{{ deploy_user }}/.bashrc
              echo 'eval "$(rbenv init -)"' >> /home/{{ deploy_user }}/.bashrc
            fi
            
            chown -R {{ deploy_user }}:{{ deploy_user }} /home/{{ deploy_user }}/.rbenv
          else
            echo "✅ rbenv already installed, skipping"
          fi
          
          # Check Ruby installation
          export PATH="/home/{{ deploy_user }}/.rbenv/bin:$PATH"
          eval "$(rbenv init -)"
          
          if ! command -v ruby >/dev/null 2>&1; then
            echo "Installing Ruby..."
            rbenv install 3.1.3
            rbenv global 3.1.3
            rbenv rehash
            
            # Install bundler
            gem install bundler
            rbenv rehash
            
            echo "✅ Ruby and Bundler installed"
          else
            echo "✅ Ruby already installed, skipping"
          fi
        else
          echo "✅ Ruby environment already complete, skipping setup"
        fi
      become_user: "{{ deploy_user }}"
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Setup Node.js only if needed
      shell: |
        if ! command -v node >/dev/null 2>&1 || [ "{{ force_installation }}" = "true" ]; then
          echo "🟢 Installing Node.js..."
          curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
          apt-get install -y nodejs
          echo "✅ Node.js installed"
        else
          echo "✅ Node.js already installed, skipping"
        fi
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Configure PostgreSQL only if needed
      shell: |
        echo "🐘 CHECKING POSTGRESQL CONFIGURATION..."
        
        # Start service if not running
        if ! systemctl is-active postgresql >/dev/null 2>&1; then
          echo "Starting PostgreSQL service..."
          systemctl start postgresql
          systemctl enable postgresql
        else
          echo "✅ PostgreSQL service already running"
        fi
        
        # Check if user exists
        if sudo -u postgres psql -c "\\du" 2>/dev/null | grep -q "{{ deploy_user }}"; then
          echo "✅ PostgreSQL user '{{ deploy_user }}' already exists, skipping"
        else
          echo "Creating PostgreSQL user..."
          sudo -u postgres createuser --createdb {{ deploy_user }} 2>/dev/null || echo "User creation attempted"
          sudo -u postgres psql -c "ALTER USER {{ deploy_user }} WITH PASSWORD 'deploy123';" 2>/dev/null || echo "Password set"
          echo "✅ PostgreSQL user configured"
        fi
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Final verification with skip logic
      shell: |
        echo "🔍 FINAL VERIFICATION"
        echo "===================="
        echo "Ruby: $(ruby --version 2>/dev/null || echo 'Not available')"
        echo "Bundler: $(bundle --version 2>/dev/null || echo 'Not available')"
        echo "Node.js: $(node --version 2>/dev/null || echo 'Not available')"
        echo "npm: $(npm --version 2>/dev/null || echo 'Not available')"
        echo "PostgreSQL: $(psql --version 2>/dev/null || echo 'Not available')"
        echo "Redis: $(redis-server --version 2>/dev/null | head -1 || echo 'Not available')"
        echo "ImageMagick: $(convert --version 2>/dev/null | head -1 || echo 'Not available')"
        
        echo ""
        echo "✅ TOOL VERIFICATION COMPLETED"
        echo "🎯 Server ready for Rails deployment"
        echo "💡 Only missing tools were installed, existing tools were skipped"
        echo "READY" > /tmp/tool_check/final_status
      become_user: "{{ deploy_user }}"

    - name: Display success with skip summary
      debug:
        msg: |
          🎉 SMART TOOL VERIFICATION COMPLETED! 🎉
          
          ✅ Intelligent skip logic applied
          ✅ Already installed tools were SKIPPED
          ✅ Only missing tools were installed
          ✅ No conflicts with existing packages
          ✅ Server ready for Rails deployment
          
          💡 Smart Features:
          ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          🔍 Detected existing Node.js installation
          🔍 Skipped npm installation (already via Node.js)
          🔍 Only installed missing packages
          🔍 Preserved existing tool configurations
PLAYBOOK_EOF

                        # Find Ansible and run playbook
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "✅ Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        if [ -z "$ANSIBLE_BINARY" ]; then
                            echo "❌ Ansible not found!"
                            exit 1
                        fi
                        
                        ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                        
                        echo "🚀 Running tool verification..."
                        
                        # Run the tool verification playbook
                        $ANSIBLE_PLAYBOOK_BINARY -i temp_ansible/inventories/${ENVIRONMENT}/hosts \\
                            temp_ansible/playbooks/verify_and_install_tools.yml \\
                            --extra-vars "force_tool_installation=${FORCE_TOOL_INSTALLATION}" \\
                            -v
                        
                        if [ $? -eq 0 ]; then
                            echo "✅ TOOL VERIFICATION COMPLETED!"
                        else
                            echo "❌ TOOL VERIFICATION FAILED!"
                            exit 1
                        fi
                        
                        # Cleanup
                        rm -rf temp_ansible
                    '''
                }
            }
        }
        
        stage('Manual Approval') {
            steps {
                script {
                    def deploymentMessage = """
🚀 READY TO DEPLOY: All tools verified!

Deploy to ${params.ENVIRONMENT} using Ansible?
"""
                    if (params.ENVIRONMENT == 'production') {
                        deploymentMessage = """
⚠️ PRODUCTION DEPLOYMENT ⚠️

✅ All tools verified and ready
🎯 Target: PRODUCTION environment

Are you sure you want to deploy to PRODUCTION?

Build: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}
Method: Ansible automation
"""
                    }
                    
                    def approver = input message: deploymentMessage,
                                        ok: "Deploy to ${params.ENVIRONMENT}",
                                        submitterParameter: 'APPROVER'
                    
                    env.DEPLOYMENT_APPROVER = approver ?: 'unknown'
                    
                    echo "Deployment approved by: ${env.DEPLOYMENT_APPROVER}"
                    echo "Deploying to: ${params.ENVIRONMENT}"
                    echo "Build to deploy: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                    echo "Tool check: ${params.SKIP_TOOL_CHECK ? 'Skipped' : 'Completed'}"
                }
            }
        }
        
        stage('Download Artifact') {
            steps {
                script {
                    cleanWs()
                    
                    def buildNumber = params.BUILD_NUMBER_TO_DEPLOY ?: ''
                    def ciJobName = 'hello-rails'
                    
                    echo "Downloading artifact from: ${ciJobName}"
                    
                    try {
                        if (buildNumber) {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'SpecificBuildSelector', buildNumber: buildNumber],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        } else {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'StatusBuildSelector', stable: false],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        }
                        
                        sh '''
                            if ls hello-world-app-*.tar.gz 1> /dev/null 2>&1; then
                                echo "✅ Artifact files found:"
                                ls -la hello-world-app-*.tar.gz
                            else
                                echo "❌ No artifact files found!"
                                exit 1
                            fi
                        '''
                        
                    } catch (Exception e) {
                        error("Failed to download artifact: ${e.message}")
                    }
                }
            }
        }
        
        stage('Setup Ansible Environment') {
            steps {
                script {
                    sh '''
                        echo "=== Setting up Ansible environment ==="
                        
                        # Find Ansible binary
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "✅ Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        echo "$ANSIBLE_BINARY" > /tmp/ansible_path
                        echo "ANSIBLE_DIR=$(dirname $ANSIBLE_BINARY)" > /tmp/ansible_env
                        
                        # Create Ansible structure
                        mkdir -p ansible/{inventories,playbooks}
                        mkdir -p ansible/inventories/staging
                        mkdir -p ansible/inventories/production
                        
                        # Create staging inventory
                        cat > ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=54.210.171.180 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=staging
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create production inventory
                        cat > ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=production
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create Rails deployment playbook using script files
                        cat > ansible/playbooks/deploy.yml << 'DEPLOY_EOF'
---
- name: Deploy Beautiful Rails Application
  hosts: webservers
  become: yes
  vars:
    app_archive_path: "/tmp/{{ app_name }}-{{ build_number | default('latest') }}.tar.gz"
  
  tasks:
    - name: Upload artifact
      shell: |
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no "{{ local_artifact_path }}" deploy@{{ ansible_host }}:/tmp/{{ app_name }}-{{ build_number }}.tar.gz
      delegate_to: localhost
      become: no

    - name: Create directories
      file:
        path: "{{ deploy_path }}/{{ rails_env }}/current"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0755'

    - name: Extract application
      unarchive:
        src: "{{ app_archive_path }}"
        dest: "{{ deploy_path }}/{{ rails_env }}/current"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        remote_src: yes

    - name: Create Rails routes script
      copy:
        dest: /tmp/create_routes.rb
        content: |
          File.open('config/routes.rb', 'w') do |f|
            f.puts "Rails.application.routes.draw do"
            f.puts "  root 'welcome#index'"
            f.puts "  get '/health', to: proc { [200, { 'Content-Type' => 'application/json' }, [{ status: 'ok', environment: Rails.env }.to_json]] }"
            f.puts "end"
          end

    - name: Create Rails controller script
      copy:
        dest: /tmp/create_controller.rb
        content: |
          require 'fileutils'
          FileUtils.mkdir_p('app/controllers')
          File.open('app/controllers/welcome_controller.rb', 'w') do |f|
            f.puts "class WelcomeController < ApplicationController"
            f.puts "  def index"
            f.puts "    @info = {"
            f.puts "      environment: Rails.env,"
            f.puts "      rails_version: Rails.version,"
            f.puts "      ruby_version: RUBY_VERSION,"
            f.puts "      deployed_at: Time.current"
            f.puts "    }"
            f.puts "  end"
            f.puts "end"
          end

    - name: Create Rails layout script
      copy:
        dest: /tmp/create_layout.sh
        mode: '0755'
        content: |
          #!/bin/bash
          mkdir -p app/views/layouts
          cat > app/views/layouts/application.html.erb << 'LAYOUT_END'
          <!DOCTYPE html>
          <html>
            <head>
              <title>Rails Deployment Success</title>
              <meta name="viewport" content="width=device-width,initial-scale=1">
              <style>
                body { font-family: system-ui, sans-serif; margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
                .container { max-width: 1000px; margin: 0 auto; padding: 20px; }
                .header { background: rgba(255,255,255,0.95); padding: 40px; border-radius: 20px; text-align: center; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
                .content { background: rgba(255,255,255,0.95); padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
                .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }
                .card { background: #f8f9fa; padding: 20px; border-radius: 15px; border-left: 4px solid #28a745; }
                .badge { display: inline-block; padding: 6px 12px; border-radius: 15px; font-size: 0.9em; font-weight: bold; margin: 5px; background: #28a745; color: white; }
                h1 { color: #2563eb; margin: 0; font-size: 2.5em; }
                h3 { color: #374151; margin-top: 0; }
                .status { font-size: 1.3em; color: #28a745; margin: 20px 0; }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="header">
                  <h1>🚀 Rails Deployment Success!</h1>
                  <p class="status">✅ Application Successfully Deployed</p>
                </div>
                <div class="content">
                  <%= yield %>
                </div>
              </div>
            </body>
          </html>
          LAYOUT_END

    - name: Create Rails view script
      copy:
        dest: /tmp/create_view.sh
        mode: '0755'
        content: |
          #!/bin/bash
          mkdir -p app/views/welcome
          cat > app/views/welcome/index.html.erb << 'VIEW_END'
          <div class="grid">
            <div class="card">
              <h3>🎯 Deployment Info</h3>
              <% if @info %>
                <p><strong>Environment:</strong> <%= @info[:environment].upcase %></p>
                <p><strong>Deployed:</strong> <%= @info[:deployed_at].strftime("%B %d, %Y at %I:%M %p") %></p>
              <% end %>
            </div>
            
            <div class="card">
              <h3>🛠️ Tech Stack</h3>
              <p><strong>Rails:</strong> <%= Rails.version %></p>
              <p><strong>Ruby:</strong> <%= RUBY_VERSION %></p>
              <p><strong>Environment:</strong> <%= Rails.env %></p>
            </div>
            
            <div class="card">
              <h3>📊 Status</h3>
              <p>✅ Rails Server Running</p>
              <p>✅ Database Connected</p>
              <p>✅ Ready to Serve</p>
            </div>
          </div>

          <div style="text-align: center; margin-top: 30px; padding: 20px; background: #e8f5e8; border-radius: 15px;">
            <h3>🎉 CI/CD Success!</h3>
            <p>Deployed with Jenkins and Ansible automation</p>
            <span class="badge">Tool Verification</span>
            <span class="badge">Rails Deployment</span>
            <span class="badge">Beautiful UI</span>
          </div>
          VIEW_END

    - name: Setup Rails with beautiful UI
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        echo "🎨 Setting up beautiful Rails application..."
        
        # Ruby environment
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        # Install gems
        bundle install --without development test
        
        # Create Rails components using scripts
        ruby /tmp/create_routes.rb
        ruby /tmp/create_controller.rb
        bash /tmp/create_layout.sh
        bash /tmp/create_view.sh
        
        echo "✅ Beautiful Rails UI components created"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"

    - name: Database operations
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo "🗄️ Database operations..."
        
        # Database setup
        RAILS_ENV={{ rails_env }} bundle exec rake db:create 2>/dev/null || echo "Database exists"
        RAILS_ENV={{ rails_env }} bundle exec rake db:migrate
        RAILS_ENV={{ rails_env }} bundle exec rake assets:precompile
        
        echo "✅ Database operations completed"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"
        RAILS_ENV: "{{ rails_env }}"

    - name: Start Rails server
      shell: |
        # Stop existing servers
        pkill -f 'python.*http.server' || true
        pkill -f 'rails server' || true
        sleep 5
        
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo "🚀 Starting beautiful Rails application..."
        
        # Start Rails server
        nohup bundle exec rails server -e {{ rails_env }} -p 3000 -b 0.0.0.0 > log/rails.log 2>&1 &
        echo $! > tmp/pids/server.pid
        
        sleep 15
        
        if ps aux | grep -v grep | grep 'rails server'; then
          echo "✅ Beautiful Rails UI started successfully"
        else
          echo "❌ Rails server failed to start"
          tail -20 log/rails.log
          exit 1
        fi
      become_user: "{{ deploy_user }}"

    - name: Verify deployment
      shell: |
        echo "🔍 VERIFYING BEAUTIFUL RAILS DEPLOYMENT"
        echo "========================================"
        
        # Check server
        if ps aux | grep -v grep | grep 'rails server'; then
          echo "✅ Rails server running"
        fi
        
        if netstat -tlnp | grep :3000; then
          echo "✅ Port 3000 listening"
        fi
        
        # Test UI
        if curl -s http://localhost:3000 | grep -i "deployment.*success"; then
          echo "✅ Beautiful Rails UI confirmed"
        fi
        
        echo "🎨 Beautiful UI live at: http://{{ ansible_host }}:3000"
      become_user: "{{ deploy_user }}"
      ignore_errors: yes

    - name: Success message
      debug:
        msg: |
          🎉 BEAUTIFUL RAILS UI DEPLOYMENT SUCCESS! 🎉
          
          ✨ Your stunning Rails application is now live!
          🌍 Access: http://{{ ansible_host }}:3000/
          🏥 Health: http://{{ ansible_host }}:3000/health
          
          Features deployed:
          ✅ Modern responsive design
          ✅ Deployment dashboard
          ✅ Technical stack display
          ✅ Status indicators
DEPLOY_EOF
                        
                        echo "✅ Ansible deployment structure created"
                    '''
                }
            }
        }
        
        stage('Prepare Deployment') {
            steps {
                script {
                    sh '''
                        # Get artifact info
                        ARTIFACT_FILE=$(ls hello-world-app-*.tar.gz | head -1)
                        BUILD_NUM=$(echo $ARTIFACT_FILE | sed 's/hello-world-app-//; s/.tar.gz//')
                        
                        echo "Artifact: $ARTIFACT_FILE"
                        echo "Build number: $BUILD_NUM"
                        
                        # Create variables file
                        cat > ansible/extra_vars.yml << EOF
build_number: ${BUILD_NUM}
app_archive_path: /tmp/hello-world-app-${BUILD_NUM}.tar.gz
local_artifact_path: $(pwd)/${ARTIFACT_FILE}
environment: ${ENVIRONMENT}
deployed_by: ${DEPLOYMENT_APPROVER}
deployed_at: $(date)
EOF
                        
                        echo "=== Deployment Variables ==="
                        cat ansible/extra_vars.yml
                    '''
                }
            }
        }
        
        stage('Test Ansible Connectivity') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            
                            echo "Testing connectivity..."
                            $ANSIBLE_BINARY -i inventories/${ENVIRONMENT}/hosts webservers -m ping
                            
                            if [ $? -eq 0 ]; then
                                echo "✅ Connectivity test passed"
                            else
                                echo "❌ Connectivity test failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deploy Beautiful Rails Application') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                            
                            echo "🚀 Deploying beautiful Rails application..."
                            
                            $ANSIBLE_PLAYBOOK_BINARY -i inventories/${ENVIRONMENT}/hosts playbooks/deploy.yml \\
                                --extra-vars @extra_vars.yml \\
                                -v
                            
                            if [ $? -eq 0 ]; then
                                echo "✅ Beautiful Rails UI deployed successfully!"
                            else
                                echo "❌ Deployment failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Post-Deployment Verification') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "🏥 Verifying beautiful Rails UI..."
                            
                            sleep 25
                            
                            MAX_RETRIES=10
                            RETRY_COUNT=0
                            
                            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                                echo "Verification attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
                                
                                if curl -f -s -o /dev/null http://${EC2_HOST}:3000/; then
                                    echo "✅ Beautiful Rails UI is live!"
                                    break
                                else
                                    echo "⏳ Waiting for UI..."
                                    sleep 10
                                    RETRY_COUNT=$((RETRY_COUNT + 1))
                                fi
                            done
                            
                            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                                echo "❌ UI verification failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deployment Summary') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "
🎉 BEAUTIFUL RAILS UI DEPLOYMENT SUCCESS! 🎉
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 Deployment Details:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Environment: ${ENVIRONMENT}
Server: ${EC2_HOST}
Approved by: ${DEPLOYMENT_APPROVER}
Build: ${BUILD_NUMBER_TO_DEPLOY:-latest}
Type: ✨ Beautiful Modern Rails UI
URL: http://${EC2_HOST}:3000
Time: $(date)

🎨 UI Features Deployed:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✨ Modern gradient background
✨ Glassmorphism cards
✨ Responsive design
✨ Deployment dashboard
✨ Technical stack display
✨ Status indicators

🚀 Rails Operations:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ RAILS_ENV=${ENVIRONMENT} rake db:create
✅ RAILS_ENV=${ENVIRONMENT} rake db:migrate
✅ RAILS_ENV=${ENVIRONMENT} rake assets:precompile
✅ Beautiful UI components created
✅ Rails server started

🔗 Access Your Beautiful Application:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌍 Main UI: http://${EC2_HOST}:3000/
🏥 Health: http://${EC2_HOST}:3000/health
🔧 SSH: ssh deploy@${EC2_HOST}

🎯 SUCCESS: Beautiful Rails UI is now live!
                            "
                        '''
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "✅ Beautiful Rails UI deployment completed successfully!"
        }
        
        failure {
            echo "❌ Deployment failed!"
        }
        
        always {
            script {
                sh '''
                    rm -f hello-world-app-*.tar.gz
                    rm -f ansible/extra_vars.yml
                    rm -rf temp_ansible
                '''
            }
            cleanWs()
        }
    }
}