pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['staging', 'production'],
            description: 'Select deployment environment'
        )
        string(
            name: 'BUILD_NUMBER_TO_DEPLOY',
            defaultValue: '',
            description: 'Build number from CI pipeline to deploy (leave empty for latest)'
        )
        booleanParam(
            name: 'FORCE_TOOL_INSTALLATION',
            defaultValue: false,
            description: 'Force reinstallation of all tools (even if already installed)'
        )
        booleanParam(
            name: 'SKIP_TOOL_CHECK',
            defaultValue: false,
            description: 'Skip tool verification and installation (use only if tools are confirmed to be installed)'
        )
    }
    
    environment {
        APP_NAME = 'hello-world-app'
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_STDOUT_CALLBACK = 'yaml'
    }
    
    stages {
        stage('Initial Server Tool Verification') {
            when {
                expression { !params.SKIP_TOOL_CHECK }
            }
            steps {
                script {
                    sh '''
                        echo "ðŸ” INITIAL SERVER TOOL VERIFICATION"
                        echo "====================================="
                        echo "Environment: ${ENVIRONMENT}"
                        echo "Force installation: ${FORCE_TOOL_INSTALLATION}"
                        echo ""
                        
                        # Create temporary Ansible structure for tool checking
                        mkdir -p temp_ansible/{inventories,playbooks}
                        mkdir -p temp_ansible/inventories/staging
                        mkdir -p temp_ansible/inventories/production
                        
                        # Create inventory files
                        cat > temp_ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=54.210.171.180 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        cat > temp_ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        # Create comprehensive tool verification playbook with SMART skip logic
                        cat > temp_ansible/playbooks/verify_and_install_tools.yml << 'PLAYBOOK_EOF'
---
- name: Smart Tool Verification - Skip Already Installed
  hosts: webservers
  become: yes
  vars:
    force_installation: "{{ force_tool_installation | default(false) }}"
  
  tasks:
    - name: Create tool check directory with proper permissions
      file:
        path: /tmp/tool_check
        state: directory
        mode: '0777'
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"

    - name: Smart tool audit script
      copy:
        dest: /tmp/smart_audit.sh
        mode: '0755'
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        content: |
          #!/bin/bash
          echo "ðŸ” SMART SERVER TOOL AUDIT"
          echo "==========================="
          echo "Date: $(date)"
          echo "Server: $(hostname)"
          echo ""
          
          # Initialize tracking
          MISSING_PACKAGES=""
          INSTALL_REQUIRED=false
          
          echo "ðŸ“¦ SYSTEM PACKAGES AUDIT:"
          echo "========================"
          
          # Check each package individually and only mark missing ones
          for pkg in curl wget git build-essential postgresql python3 unzip; do
            if dpkg -l 2>/dev/null | grep -q "^ii.*$pkg "; then
              echo "  âœ… $pkg - installed (SKIP)"
            else
              echo "  âŒ $pkg - MISSING (WILL INSTALL)"
              MISSING_PACKAGES="$MISSING_PACKAGES $pkg"
              INSTALL_REQUIRED=true
            fi
          done
          
          # Check redis-server specifically
          if dpkg -l 2>/dev/null | grep -q "^ii.*redis-server"; then
            echo "  âœ… redis-server - installed (SKIP)"
          else
            echo "  âŒ redis-server - MISSING (WILL INSTALL)"
            MISSING_PACKAGES="$MISSING_PACKAGES redis-server"
            INSTALL_REQUIRED=true
          fi
          
          # Check imagemagick specifically
          if dpkg -l 2>/dev/null | grep -q "^ii.*imagemagick"; then
            echo "  âœ… imagemagick - installed (SKIP)"
          else
            echo "  âŒ imagemagick - MISSING (WILL INSTALL)"
            MISSING_PACKAGES="$MISSING_PACKAGES imagemagick"
            INSTALL_REQUIRED=true
          fi
          
          # Skip npm check since it's already installed via Node.js
          if command -v npm >/dev/null 2>&1; then
            echo "  âœ… npm - installed via Node.js (SKIP)"
          else
            echo "  âŒ npm - NOT FOUND"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "ðŸ’Ž RUBY ENVIRONMENT AUDIT:"
          echo "========================="
          
          if [ -d "/home/{{ deploy_user }}/.rbenv" ]; then
            echo "  âœ… rbenv - installed (SKIP)"
          else
            echo "  âŒ rbenv - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v ruby >/dev/null 2>&1; then
            RUBY_VERSION=$(ruby --version)
            echo "  âœ… Ruby - $RUBY_VERSION (SKIP)"
          else
            echo "  âŒ Ruby - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v bundle >/dev/null 2>&1; then
            BUNDLER_VERSION=$(bundle --version)
            echo "  âœ… Bundler - $BUNDLER_VERSION (SKIP)"
          else
            echo "  âŒ Bundler - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "ðŸŸ¢ NODE.JS ENVIRONMENT AUDIT:"
          echo "============================"
          
          if command -v node >/dev/null 2>&1; then
            NODE_VERSION=$(node --version)
            echo "  âœ… Node.js - $NODE_VERSION (SKIP)"
          else
            echo "  âŒ Node.js - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v npm >/dev/null 2>&1; then
            NPM_VERSION=$(npm --version)
            echo "  âœ… npm - $NPM_VERSION (SKIP)"
          else
            echo "  âŒ npm - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "ðŸ˜ POSTGRESQL AUDIT:"
          echo "==================="
          
          if command -v psql >/dev/null 2>&1; then
            PSQL_VERSION=$(psql --version)
            echo "  âœ… PostgreSQL client - $PSQL_VERSION (SKIP)"
          else
            echo "  âŒ PostgreSQL client - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if systemctl is-active postgresql >/dev/null 2>&1; then
            echo "  âœ… PostgreSQL service - RUNNING (SKIP)"
          else
            echo "  âŒ PostgreSQL service - NOT RUNNING (WILL CONFIGURE)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "ðŸ“‹ SMART AUDIT SUMMARY:"
          echo "======================"
          
          if [ "$INSTALL_REQUIRED" = "true" ] || [ "{{ force_installation }}" = "true" ]; then
            echo "ðŸ”§ SELECTIVE INSTALLATION REQUIRED"
            echo "Only missing packages will be installed"
            echo "Already installed packages will be SKIPPED"
            echo "INSTALL_REQUIRED" > /tmp/tool_check/status
          else
            echo "âœ… ALL TOOLS ALREADY INSTALLED"
            echo "No installation needed - all tools present"
            echo "TOOLS_READY" > /tmp/tool_check/status
          fi
          
          # Store only missing packages (exclude already installed)
          echo "$MISSING_PACKAGES" > /tmp/tool_check/missing_packages
          
          echo ""
          echo "ðŸ“¦ Packages to install: $MISSING_PACKAGES"
          echo "ðŸ’¡ Installed packages will be skipped automatically"

    - name: Execute smart tool audit
      shell: /tmp/smart_audit.sh
      register: tool_audit
      become_user: "{{ deploy_user }}"

    - name: Display audit results
      debug:
        msg: "{{ tool_audit.stdout_lines }}"

    - name: Read tool status
      shell: cat /tmp/tool_check/status
      register: tool_status
      ignore_errors: yes

    - name: Read missing packages list
      shell: cat /tmp/tool_check/missing_packages
      register: missing_packages
      ignore_errors: yes

    - name: Install ONLY missing system packages
      apt:
        name: "{{ missing_packages.stdout.split() }}"
        state: present
        update_cache: yes
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - missing_packages.stdout | trim | length > 0
      ignore_errors: yes

    - name: Install redis-server separately if missing
      apt:
        name: redis-server
        state: present
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - "'redis-server' in missing_packages.stdout"
      ignore_errors: yes

    - name: Install imagemagick separately if missing
      apt:
        name: imagemagick
        state: present
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - "'imagemagick' in missing_packages.stdout"
      ignore_errors: yes

    - name: Setup Ruby environment only if needed
      shell: |
        # Check if Ruby setup is actually needed
        if [ ! -d "/home/{{ deploy_user }}/.rbenv" ] || ! command -v ruby >/dev/null 2>&1 || ! command -v bundle >/dev/null 2>&1 || [ "{{ force_installation }}" = "true" ]; then
          echo "ðŸ’Ž SETTING UP RUBY ENVIRONMENT..."
          
          # Install rbenv only if missing
          if [ ! -d "/home/{{ deploy_user }}/.rbenv" ]; then
            echo "Installing rbenv..."
            git clone https://github.com/rbenv/rbenv.git /home/{{ deploy_user }}/.rbenv
            git clone https://github.com/rbenv/ruby-build.git /home/{{ deploy_user }}/.rbenv/plugins/ruby-build
            
            # Add to bashrc if not present
            if ! grep -q 'rbenv' /home/{{ deploy_user }}/.bashrc; then
              echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> /home/{{ deploy_user }}/.bashrc
              echo 'eval "$(rbenv init -)"' >> /home/{{ deploy_user }}/.bashrc
            fi
            
            chown -R {{ deploy_user }}:{{ deploy_user }} /home/{{ deploy_user }}/.rbenv
          else
            echo "âœ… rbenv already installed, skipping"
          fi
          
          # Check Ruby installation
          export PATH="/home/{{ deploy_user }}/.rbenv/bin:$PATH"
          eval "$(rbenv init -)"
          
          if ! command -v ruby >/dev/null 2>&1; then
            echo "Installing Ruby..."
            rbenv install 3.1.3
            rbenv global 3.1.3
            rbenv rehash
            
            # Install bundler
            gem install bundler
            rbenv rehash
            
            echo "âœ… Ruby and Bundler installed"
          else
            echo "âœ… Ruby already installed, skipping"
          fi
        else
          echo "âœ… Ruby environment already complete, skipping setup"
        fi
      become_user: "{{ deploy_user }}"
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Setup Node.js only if needed
      shell: |
        if ! command -v node >/dev/null 2>&1 || [ "{{ force_installation }}" = "true" ]; then
          echo "ðŸŸ¢ Installing Node.js..."
          curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
          apt-get install -y nodejs
          echo "âœ… Node.js installed"
        else
          echo "âœ… Node.js already installed, skipping"
        fi
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Configure PostgreSQL only if needed
      shell: |
        echo "ðŸ˜ CHECKING POSTGRESQL CONFIGURATION..."
        
        # Start service if not running
        if ! systemctl is-active postgresql >/dev/null 2>&1; then
          echo "Starting PostgreSQL service..."
          systemctl start postgresql
          systemctl enable postgresql
        else
          echo "âœ… PostgreSQL service already running"
        fi
        
        # Check if user exists
        if sudo -u postgres psql -c "\\du" 2>/dev/null | grep -q "{{ deploy_user }}"; then
          echo "âœ… PostgreSQL user '{{ deploy_user }}' already exists, skipping"
        else
          echo "Creating PostgreSQL user..."
          sudo -u postgres createuser --createdb {{ deploy_user }} 2>/dev/null || echo "User creation attempted"
          sudo -u postgres psql -c "ALTER USER {{ deploy_user }} WITH PASSWORD 'deploy123';" 2>/dev/null || echo "Password set"
          echo "âœ… PostgreSQL user configured"
        fi
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Final verification with skip logic
      shell: |
        echo "ðŸ” FINAL VERIFICATION"
        echo "===================="
        echo "Ruby: $(ruby --version 2>/dev/null || echo 'Not available')"
        echo "Bundler: $(bundle --version 2>/dev/null || echo 'Not available')"
        echo "Node.js: $(node --version 2>/dev/null || echo 'Not available')"
        echo "npm: $(npm --version 2>/dev/null || echo 'Not available')"
        echo "PostgreSQL: $(psql --version 2>/dev/null || echo 'Not available')"
        echo "Redis: $(redis-server --version 2>/dev/null | head -1 || echo 'Not available')"
        echo "ImageMagick: $(convert --version 2>/dev/null | head -1 || echo 'Not available')"
        
        echo ""
        echo "âœ… TOOL VERIFICATION COMPLETED"
        echo "ðŸŽ¯ Server ready for Rails deployment"
        echo "ðŸ’¡ Only missing tools were installed, existing tools were skipped"
        echo "READY" > /tmp/tool_check/final_status
      become_user: "{{ deploy_user }}"

    - name: Display success with skip summary
      debug:
        msg: |
          ðŸŽ‰ SMART TOOL VERIFICATION COMPLETED! ðŸŽ‰
          
          âœ… Intelligent skip logic applied
          âœ… Already installed tools were SKIPPED
          âœ… Only missing tools were installed
          âœ… No conflicts with existing packages
          âœ… Server ready for Rails deployment
          
          ðŸ’¡ Smart Features:
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          ðŸ” Detected existing Node.js installation
          ðŸ” Skipped npm installation (already via Node.js)
          ðŸ” Only installed missing packages
          ðŸ” Preserved existing tool configurations
PLAYBOOK_EOF

                        # Find Ansible and run playbook
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "âœ… Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        if [ -z "$ANSIBLE_BINARY" ]; then
                            echo "âŒ Ansible not found!"
                            exit 1
                        fi
                        
                        ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                        
                        echo "ðŸš€ Running tool verification..."
                        
                        # Run the tool verification playbook
                        $ANSIBLE_PLAYBOOK_BINARY -i temp_ansible/inventories/${ENVIRONMENT}/hosts \\
                            temp_ansible/playbooks/verify_and_install_tools.yml \\
                            --extra-vars "force_tool_installation=${FORCE_TOOL_INSTALLATION}" \\
                            -v
                        
                        if [ $? -eq 0 ]; then
                            echo "âœ… TOOL VERIFICATION COMPLETED!"
                        else
                            echo "âŒ TOOL VERIFICATION FAILED!"
                            exit 1
                        fi
                        
                        # Cleanup
                        rm -rf temp_ansible
                    '''
                }
            }
        }
        
        stage('Manual Approval') {
            steps {
                script {
                    def deploymentMessage = """
ðŸš€ READY TO DEPLOY: All tools verified!

Deploy Rails application to ${params.ENVIRONMENT}?
"""
                    if (params.ENVIRONMENT == 'production') {
                        deploymentMessage = """
âš ï¸ PRODUCTION DEPLOYMENT âš ï¸

âœ… All tools verified and ready
ðŸŽ¯ Target: PRODUCTION environment

Are you sure you want to deploy to PRODUCTION?

Build: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}
Method: Ansible automation with Rails server
"""
                    }
                    
                    def approver = input message: deploymentMessage,
                                        ok: "Deploy to ${params.ENVIRONMENT}",
                                        submitterParameter: 'APPROVER'
                    
                    env.DEPLOYMENT_APPROVER = approver ?: 'unknown'
                    
                    echo "Deployment approved by: ${env.DEPLOYMENT_APPROVER}"
                    echo "Deploying to: ${params.ENVIRONMENT}"
                    echo "Build to deploy: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                    echo "Tool check: ${params.SKIP_TOOL_CHECK ? 'Skipped' : 'Completed'}"
                }
            }
        }
        
        stage('Download Artifact') {
            steps {
                script {
                    cleanWs()
                    
                    def buildNumber = params.BUILD_NUMBER_TO_DEPLOY ?: ''
                    def ciJobName = 'hello-rails'
                    
                    echo "Downloading artifact from: ${ciJobName}"
                    
                    try {
                        if (buildNumber) {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'SpecificBuildSelector', buildNumber: buildNumber],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        } else {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'StatusBuildSelector', stable: false],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        }
                        
                        sh '''
                            if ls hello-world-app-*.tar.gz 1> /dev/null 2>&1; then
                                echo "âœ… Artifact files found:"
                                ls -la hello-world-app-*.tar.gz
                            else
                                echo "âŒ No artifact files found!"
                                exit 1
                            fi
                        '''
                        
                    } catch (Exception e) {
                        error("Failed to download artifact: ${e.message}")
                    }
                }
            }
        }
        
        stage('Setup Ansible Environment') {
            steps {
                script {
                    sh '''
                        echo "=== Setting up Ansible environment ==="
                        
                        # Find Ansible binary
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "âœ… Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        echo "$ANSIBLE_BINARY" > /tmp/ansible_path
                        echo "ANSIBLE_DIR=$(dirname $ANSIBLE_BINARY)" > /tmp/ansible_env
                        
                        # Create Ansible structure
                        mkdir -p ansible/{inventories,playbooks}
                        mkdir -p ansible/inventories/staging
                        mkdir -p ansible/inventories/production
                        
                        # Create staging inventory
                        cat > ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=54.210.171.180 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=staging
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create production inventory
                        cat > ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=production
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create Rails deployment playbook with your specific Rails server commands
                        cat > ansible/playbooks/deploy.yml << 'DEPLOY_EOF'
---
- name: Deploy Rails Application with Rails Server
  hosts: webservers
  become: yes
  vars:
    app_archive_path: "/tmp/{{ app_name }}-{{ build_number | default('latest') }}.tar.gz"

  tasks:
    - name: Upload artifact
      shell: |
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no "{{ local_artifact_path }}" deploy@{{ ansible_host }}:/tmp/{{ app_name }}-{{ build_number }}.tar.gz
      delegate_to: localhost
      become: no

    - name: Create deployment directories
      file:
        path: "{{ deploy_path }}/{{ rails_env }}/current"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0755'

    - name: Extract application
      unarchive:
        src: "{{ app_archive_path }}"
        dest: "{{ deploy_path }}/{{ rails_env }}/current"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        remote_src: yes

    - name: Install Ruby dependencies
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        
        echo "Installing Ruby dependencies..."
        bundle install --without development test
        
        echo "Ruby dependencies installed"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"

    - name: Database operations
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo "Setting up database..."
        
        RAILS_ENV={{ rails_env }} bundle exec rake db:create 2>/dev/null || echo "Database already exists"
        RAILS_ENV={{ rails_env }} bundle exec rake db:migrate
        
        if [ -d "app/assets" ]; then
          RAILS_ENV={{ rails_env }} bundle exec rake assets:precompile
        fi
        
        echo "Database operations completed"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"
        RAILS_ENV: "{{ rails_env }}"

    - name: Stop existing servers
      shell: |
        echo "Stopping existing servers..."
        
        pkill -f 'python.*http.server' || true
        pkill -f 'rails server' || true
        
        sleep 5
        
        echo "Existing servers stopped"
      become_user: "{{ deploy_user }}"

    - name: Start Rails Server
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        
        export RAILS_ENV={{ rails_env }}
        export SECRET_KEY_BASE=$(bundle exec rails secret)
        
        echo "Starting Rails server..."
        echo "Environment: $RAILS_ENV"
        
        mkdir -p log tmp/pids
        
        nohup bundle exec rails server -e {{ rails_env }} -p 3000 -b 0.0.0.0 > log/rails.log 2>&1 &
        
        echo $! > tmp/pids/server.pid
        
        echo "Rails server started in background"
        echo "Process ID: $(cat tmp/pids/server.pid)"
        
        sleep 15
        
        if ps aux | grep -v grep | grep 'rails server'; then
          echo "Rails server is running successfully"
          echo "Server accessible at: http://{{ ansible_host }}:3000"
        else
          echo "Rails server failed to start"
          echo "Checking logs:"
          tail -20 log/rails.log
          exit 1
        fi
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"

    - name: Verify Rails deployment
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        echo "VERIFYING RAILS DEPLOYMENT"
        echo "=========================="
        
        if ps aux | grep -v grep | grep 'rails server'; then
          echo "Rails server process running"
        else
          echo "Rails server process not found"
        fi
        
        if netstat -tlnp | grep :3000; then
          echo "Port 3000 is listening"
        else
          echo "Port 3000 not listening"
        fi
        
        sleep 5
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 || echo "000")
        if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "404" ] || [ "$HTTP_CODE" = "500" ]; then
          echo "Rails application responding to HTTP requests (HTTP $HTTP_CODE)"
        else
          echo "Rails application might still be starting up (HTTP $HTTP_CODE)"
        fi
        
        echo ""
        echo "Server Status:"
        echo "Environment: {{ rails_env }}"
        echo "Application Path: {{ deploy_path }}/{{ rails_env }}/current"
        echo "Access URL: http://{{ ansible_host }}:3000"
        echo "Log File: {{ deploy_path }}/{{ rails_env }}/current/log/rails.log"
      become_user: "{{ deploy_user }}"
      ignore_errors: yes

    - name: Display deployment success message
      debug:
        msg: |
          RAILS APPLICATION DEPLOYMENT SUCCESS!
          
          Your Rails application is now running!
          Access: http://{{ ansible_host }}:3000/
          Logs: {{ deploy_path }}/{{ rails_env }}/current/log/rails.log
          
          Server Details:
          Environment: {{ rails_env }}
          Ruby/Rails server running on port 3000
          Database migrations completed
          Assets precompiled (if applicable)
          Secret key base generated
          
          Commands used:
          export RAILS_ENV={{ rails_env }}
          export SECRET_KEY_BASE=$(bundle exec rails secret)
          bundle exec rails server -e {{ rails_env }} -p 3000 -b 0.0.0.0
DEPLOY_EOF
                        
                        echo "âœ… Ansible Rails deployment structure created"
                    '''
                }
            }
        }
        
        stage('Prepare Deployment') {
            steps {
                script {
                    sh '''
                        # Get artifact info
                        ARTIFACT_FILE=$(ls hello-world-app-*.tar.gz | head -1)
                        BUILD_NUM=$(echo $ARTIFACT_FILE | sed 's/hello-world-app-//; s/.tar.gz//')
                        
                        echo "Artifact: $ARTIFACT_FILE"
                        echo "Build number: $BUILD_NUM"
                        
                        # Create variables file
                        cat > ansible/extra_vars.yml << EOF
build_number: ${BUILD_NUM}
app_archive_path: /tmp/hello-world-app-${BUILD_NUM}.tar.gz
local_artifact_path: $(pwd)/${ARTIFACT_FILE}
environment: ${ENVIRONMENT}
deployed_by: ${DEPLOYMENT_APPROVER}
deployed_at: $(date)
EOF
                        
                        echo "=== Deployment Variables ==="
                        cat ansible/extra_vars.yml
                    '''
                }
            }
        }
        
        stage('Test Ansible Connectivity') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            
                            echo "Testing connectivity..."
                            $ANSIBLE_BINARY -i inventories/${ENVIRONMENT}/hosts webservers -m ping
                            
                            if [ $? -eq 0 ]; then
                                echo "âœ… Connectivity test passed"
                            else
                                echo "âŒ Connectivity test failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deploy Rails Application') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                            
                            echo "ðŸš€ Deploying Rails application..."
                            
                            $ANSIBLE_PLAYBOOK_BINARY -i inventories/${ENVIRONMENT}/hosts playbooks/deploy.yml \\
                                --extra-vars @extra_vars.yml \\
                                -v
                            
                            if [ $? -eq 0 ]; then
                                echo "âœ… Rails application deployed successfully!"
                            else
                                echo "âŒ Deployment failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Post-Deployment Verification') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "ðŸ¥ Verifying Rails application..."
                            
                            # Wait for Rails application to fully start
                            sleep 30
                            
                            MAX_RETRIES=12
                            RETRY_COUNT=0
                            
                            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                                echo "Verification attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
                                
                                # Check if Rails server is responding
                                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://${EC2_HOST}:3000/ || echo "000")
                                
                                if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "404" ] || [ "$HTTP_CODE" = "500" ]; then
                                    echo "âœ… Rails application is responding! (HTTP $HTTP_CODE)"
                                    break
                                else
                                    echo "â³ Waiting for Rails application... (HTTP $HTTP_CODE)"
                                    sleep 15
                                    RETRY_COUNT=$((RETRY_COUNT + 1))
                                fi
                            done
                            
                            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                                echo "âŒ Rails application verification failed after $MAX_RETRIES attempts"
                                echo "ðŸ” Attempting to check server status..."
                                
                                # Try to get more information about the server state
                                curl -v http://${EC2_HOST}:3000/ || true
                                
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deployment Summary') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "
ðŸŽ‰ RAILS APPLICATION DEPLOYMENT SUCCESS! ðŸŽ‰
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“Š Deployment Details:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Environment: ${ENVIRONMENT}
Server: ${EC2_HOST}
Approved by: ${DEPLOYMENT_APPROVER}
Build: ${BUILD_NUMBER_TO_DEPLOY:-latest}
Type: ðŸš€ Rails Application Server
URL: http://${EC2_HOST}:3000
Time: $(date)

ðŸ”§ Rails Server Configuration:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… RAILS_ENV=${ENVIRONMENT}
âœ… SECRET_KEY_BASE=generated
âœ… Server: rails server -e ${ENVIRONMENT} -p 3000 -b 0.0.0.0
âœ… Running in background with nohup
âœ… Process ID saved to tmp/pids/server.pid

ðŸ—„ï¸ Database Operations:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… bundle exec rake db:create
âœ… bundle exec rake db:migrate  
âœ… bundle exec rake assets:precompile
âœ… Ruby dependencies installed

ðŸ”— Access Your Rails Application:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸŒ Main App: http://${EC2_HOST}:3000/
ðŸ“ Logs: /var/www/hello-world-app/${ENVIRONMENT}/current/log/rails.log
ðŸ”§ SSH: ssh deploy@${EC2_HOST}

ðŸŽ¯ SUCCESS: Rails application is now live and running!
                            "
                        '''
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "âœ… Rails application deployment completed successfully!"
        }
        
        failure {
            echo "âŒ Rails deployment failed!"
        }
        
        always {
            script {
                sh '''
                    rm -f hello-world-app-*.tar.gz
                    rm -f ansible/extra_vars.yml
                    rm -rf temp_ansible
                '''
            }
            cleanWs()
        }
    }
}