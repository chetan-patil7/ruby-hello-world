pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['staging', 'production'],
            description: 'Select deployment environment'
        )
        string(
            name: 'BUILD_NUMBER_TO_DEPLOY',
            defaultValue: '',
            description: 'Build number from CI pipeline to deploy (leave empty for latest)'
        )
        booleanParam(
            name: 'FORCE_TOOL_INSTALLATION',
            defaultValue: false,
            description: 'Force reinstallation of all tools (even if already installed)'
        )
        booleanParam(
            name: 'SKIP_TOOL_CHECK',
            defaultValue: false,
            description: 'Skip tool verification and installation (use only if tools are confirmed to be installed)'
        )
    }
    
    environment {
        APP_NAME = 'hello-world-app'
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_STDOUT_CALLBACK = 'yaml'
    }
    
    stages {
        stage('Initial Server Tool Verification') {
            when {
                expression { !params.SKIP_TOOL_CHECK }
            }
            steps {
                script {
                    sh '''
                        echo "üîç INITIAL SERVER TOOL VERIFICATION"
                        echo "====================================="
                        echo "Environment: ${ENVIRONMENT}"
                        echo "Force installation: ${FORCE_TOOL_INSTALLATION}"
                        echo ""
                        
                        # Create temporary Ansible structure for tool checking
                        mkdir -p temp_ansible/{inventories,playbooks}
                        mkdir -p temp_ansible/inventories/staging
                        mkdir -p temp_ansible/inventories/production
                        
                        # Create inventory files
                        cat > temp_ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=54.210.171.180 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        cat > temp_ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        # Create comprehensive tool verification playbook with SMART skip logic
                        cat > temp_ansible/playbooks/verify_and_install_tools.yml << 'PLAYBOOK_EOF'
---
- name: Smart Tool Verification - Skip Already Installed
  hosts: webservers
  become: yes
  vars:
    force_installation: "{{ force_tool_installation | default(false) }}"
  
  tasks:
    - name: Create tool check directory with proper permissions
      file:
        path: /tmp/tool_check
        state: directory
        mode: '0777'
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"

    - name: Smart tool audit script
      copy:
        dest: /tmp/smart_audit.sh
        mode: '0755'
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        content: |
          #!/bin/bash
          echo "üîç SMART SERVER TOOL AUDIT"
          echo "==========================="
          echo "Date: $(date)"
          echo "Server: $(hostname)"
          echo ""
          
          # Initialize tracking
          MISSING_PACKAGES=""
          INSTALL_REQUIRED=false
          
          echo "üì¶ SYSTEM PACKAGES AUDIT:"
          echo "========================"
          
          # Check each package individually and only mark missing ones
          for pkg in curl wget git build-essential postgresql python3 unzip; do
            if dpkg -l 2>/dev/null | grep -q "^ii.*$pkg "; then
              echo "  ‚úÖ $pkg - installed (SKIP)"
            else
              echo "  ‚ùå $pkg - MISSING (WILL INSTALL)"
              MISSING_PACKAGES="$MISSING_PACKAGES $pkg"
              INSTALL_REQUIRED=true
            fi
          done
          
          # Check redis-server specifically
          if dpkg -l 2>/dev/null | grep -q "^ii.*redis-server"; then
            echo "  ‚úÖ redis-server - installed (SKIP)"
          else
            echo "  ‚ùå redis-server - MISSING (WILL INSTALL)"
            MISSING_PACKAGES="$MISSING_PACKAGES redis-server"
            INSTALL_REQUIRED=true
          fi
          
          # Check imagemagick specifically
          if dpkg -l 2>/dev/null | grep -q "^ii.*imagemagick"; then
            echo "  ‚úÖ imagemagick - installed (SKIP)"
          else
            echo "  ‚ùå imagemagick - MISSING (WILL INSTALL)"
            MISSING_PACKAGES="$MISSING_PACKAGES imagemagick"
            INSTALL_REQUIRED=true
          fi
          
          # Skip npm check since it's already installed via Node.js
          if command -v npm >/dev/null 2>&1; then
            echo "  ‚úÖ npm - installed via Node.js (SKIP)"
          else
            echo "  ‚ùå npm - NOT FOUND"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "üíé RUBY ENVIRONMENT AUDIT:"
          echo "========================="
          
          if [ -d "/home/{{ deploy_user }}/.rbenv" ]; then
            echo "  ‚úÖ rbenv - installed (SKIP)"
          else
            echo "  ‚ùå rbenv - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v ruby >/dev/null 2>&1; then
            RUBY_VERSION=$(ruby --version)
            echo "  ‚úÖ Ruby - $RUBY_VERSION (SKIP)"
          else
            echo "  ‚ùå Ruby - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v bundle >/dev/null 2>&1; then
            BUNDLER_VERSION=$(bundle --version)
            echo "  ‚úÖ Bundler - $BUNDLER_VERSION (SKIP)"
          else
            echo "  ‚ùå Bundler - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "üü¢ NODE.JS ENVIRONMENT AUDIT:"
          echo "============================"
          
          if command -v node >/dev/null 2>&1; then
            NODE_VERSION=$(node --version)
            echo "  ‚úÖ Node.js - $NODE_VERSION (SKIP)"
          else
            echo "  ‚ùå Node.js - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if command -v npm >/dev/null 2>&1; then
            NPM_VERSION=$(npm --version)
            echo "  ‚úÖ npm - $NPM_VERSION (SKIP)"
          else
            echo "  ‚ùå npm - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "üêò POSTGRESQL AUDIT:"
          echo "==================="
          
          if command -v psql >/dev/null 2>&1; then
            PSQL_VERSION=$(psql --version)
            echo "  ‚úÖ PostgreSQL client - $PSQL_VERSION (SKIP)"
          else
            echo "  ‚ùå PostgreSQL client - NOT INSTALLED (WILL INSTALL)"
            INSTALL_REQUIRED=true
          fi
          
          if systemctl is-active postgresql >/dev/null 2>&1; then
            echo "  ‚úÖ PostgreSQL service - RUNNING (SKIP)"
          else
            echo "  ‚ùå PostgreSQL service - NOT RUNNING (WILL CONFIGURE)"
            INSTALL_REQUIRED=true
          fi
          
          echo ""
          echo "üìã SMART AUDIT SUMMARY:"
          echo "======================"
          
          if [ "$INSTALL_REQUIRED" = "true" ] || [ "{{ force_installation }}" = "true" ]; then
            echo "üîß SELECTIVE INSTALLATION REQUIRED"
            echo "Only missing packages will be installed"
            echo "Already installed packages will be SKIPPED"
            echo "INSTALL_REQUIRED" > /tmp/tool_check/status
          else
            echo "‚úÖ ALL TOOLS ALREADY INSTALLED"
            echo "No installation needed - all tools present"
            echo "TOOLS_READY" > /tmp/tool_check/status
          fi
          
          # Store only missing packages (exclude already installed)
          echo "$MISSING_PACKAGES" > /tmp/tool_check/missing_packages
          
          echo ""
          echo "üì¶ Packages to install: $MISSING_PACKAGES"
          echo "üí° Installed packages will be skipped automatically"

    - name: Execute smart tool audit
      shell: /tmp/smart_audit.sh
      register: tool_audit
      become_user: "{{ deploy_user }}"

    - name: Display audit results
      debug:
        msg: "{{ tool_audit.stdout_lines }}"

    - name: Read tool status
      shell: cat /tmp/tool_check/status
      register: tool_status
      ignore_errors: yes

    - name: Read missing packages list
      shell: cat /tmp/tool_check/missing_packages
      register: missing_packages
      ignore_errors: yes

    - name: Install ONLY missing system packages
      apt:
        name: "{{ missing_packages.stdout.split() }}"
        state: present
        update_cache: yes
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - missing_packages.stdout | trim | length > 0
      ignore_errors: yes

    - name: Install redis-server separately if missing
      apt:
        name: redis-server
        state: present
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - "'redis-server' in missing_packages.stdout"
      ignore_errors: yes

    - name: Install imagemagick separately if missing
      apt:
        name: imagemagick
        state: present
      when: 
        - tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool
        - missing_packages.stdout is defined
        - "'imagemagick' in missing_packages.stdout"
      ignore_errors: yes

    - name: Setup Ruby environment only if needed
      shell: |
        # Check if Ruby setup is actually needed
        if [ ! -d "/home/{{ deploy_user }}/.rbenv" ] || ! command -v ruby >/dev/null 2>&1 || ! command -v bundle >/dev/null 2>&1 || [ "{{ force_installation }}" = "true" ]; then
          echo "üíé SETTING UP RUBY ENVIRONMENT..."
          
          # Install rbenv only if missing
          if [ ! -d "/home/{{ deploy_user }}/.rbenv" ]; then
            echo "Installing rbenv..."
            git clone https://github.com/rbenv/rbenv.git /home/{{ deploy_user }}/.rbenv
            git clone https://github.com/rbenv/ruby-build.git /home/{{ deploy_user }}/.rbenv/plugins/ruby-build
            
            # Add to bashrc if not present
            if ! grep -q 'rbenv' /home/{{ deploy_user }}/.bashrc; then
              echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> /home/{{ deploy_user }}/.bashrc
              echo 'eval "$(rbenv init -)"' >> /home/{{ deploy_user }}/.bashrc
            fi
            
            chown -R {{ deploy_user }}:{{ deploy_user }} /home/{{ deploy_user }}/.rbenv
          else
            echo "‚úÖ rbenv already installed, skipping"
          fi
          
          # Check Ruby installation
          export PATH="/home/{{ deploy_user }}/.rbenv/bin:$PATH"
          eval "$(rbenv init -)"
          
          if ! command -v ruby >/dev/null 2>&1; then
            echo "Installing Ruby..."
            rbenv install 3.1.3
            rbenv global 3.1.3
            rbenv rehash
            
            # Install bundler
            gem install bundler
            rbenv rehash
            
            echo "‚úÖ Ruby and Bundler installed"
          else
            echo "‚úÖ Ruby already installed, skipping"
          fi
        else
          echo "‚úÖ Ruby environment already complete, skipping setup"
        fi
      become_user: "{{ deploy_user }}"
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Setup Node.js only if needed
      shell: |
        if ! command -v node >/dev/null 2>&1 || [ "{{ force_installation }}" = "true" ]; then
          echo "üü¢ Installing Node.js..."
          curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
          apt-get install -y nodejs
          echo "‚úÖ Node.js installed"
        else
          echo "‚úÖ Node.js already installed, skipping"
        fi
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Configure PostgreSQL only if needed
      shell: |
        echo "üêò CHECKING POSTGRESQL CONFIGURATION..."
        
        # Start service if not running
        if ! systemctl is-active postgresql >/dev/null 2>&1; then
          echo "Starting PostgreSQL service..."
          systemctl start postgresql
          systemctl enable postgresql
        else
          echo "‚úÖ PostgreSQL service already running"
        fi
        
        # Check if user exists
        if sudo -u postgres psql -c "\\du" 2>/dev/null | grep -q "{{ deploy_user }}"; then
          echo "‚úÖ PostgreSQL user '{{ deploy_user }}' already exists, skipping"
        else
          echo "Creating PostgreSQL user..."
          sudo -u postgres createuser --createdb {{ deploy_user }} 2>/dev/null || echo "User creation attempted"
          sudo -u postgres psql -c "ALTER USER {{ deploy_user }} WITH PASSWORD 'deploy123';" 2>/dev/null || echo "Password set"
          echo "‚úÖ PostgreSQL user configured"
        fi
      when: tool_status.stdout == "INSTALL_REQUIRED" or force_installation|bool

    - name: Final verification with skip logic
      shell: |
        echo "üîç FINAL VERIFICATION"
        echo "===================="
        echo "Ruby: $(ruby --version 2>/dev/null || echo 'Not available')"
        echo "Bundler: $(bundle --version 2>/dev/null || echo 'Not available')"
        echo "Node.js: $(node --version 2>/dev/null || echo 'Not available')"
        echo "npm: $(npm --version 2>/dev/null || echo 'Not available')"
        echo "PostgreSQL: $(psql --version 2>/dev/null || echo 'Not available')"
        echo "Redis: $(redis-server --version 2>/dev/null | head -1 || echo 'Not available')"
        echo "ImageMagick: $(convert --version 2>/dev/null | head -1 || echo 'Not available')"
        
        echo ""
        echo "‚úÖ TOOL VERIFICATION COMPLETED"
        echo "üéØ Server ready for Rails deployment"
        echo "üí° Only missing tools were installed, existing tools were skipped"
        echo "READY" > /tmp/tool_check/final_status
      become_user: "{{ deploy_user }}"

    - name: Display success with skip summary
      debug:
        msg: |
          üéâ SMART TOOL VERIFICATION COMPLETED! üéâ
          
          ‚úÖ Intelligent skip logic applied
          ‚úÖ Already installed tools were SKIPPED
          ‚úÖ Only missing tools were installed
          ‚úÖ No conflicts with existing packages
          ‚úÖ Server ready for Rails deployment
          
          üí° Smart Features:
          ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
          üîç Detected existing Node.js installation
          üîç Skipped npm installation (already via Node.js)
          üîç Only installed missing packages
          üîç Preserved existing tool configurations
PLAYBOOK_EOF

                        # Find Ansible and run playbook
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "‚úÖ Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        if [ -z "$ANSIBLE_BINARY" ]; then
                            echo "‚ùå Ansible not found!"
                            exit 1
                        fi
                        
                        ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                        
                        echo "üöÄ Running tool verification..."
                        
                        # Run the tool verification playbook
                        $ANSIBLE_PLAYBOOK_BINARY -i temp_ansible/inventories/${ENVIRONMENT}/hosts \\
                            temp_ansible/playbooks/verify_and_install_tools.yml \\
                            --extra-vars "force_tool_installation=${FORCE_TOOL_INSTALLATION}" \\
                            -v
                        
                        if [ $? -eq 0 ]; then
                            echo "‚úÖ TOOL VERIFICATION COMPLETED!"
                        else
                            echo "‚ùå TOOL VERIFICATION FAILED!"
                            exit 1
                        fi
                        
                        # Cleanup
                        rm -rf temp_ansible
                    '''
                }
            }
        }
        
        stage('Manual Approval') {
            steps {
                script {
                    def deploymentMessage = """
üöÄ READY TO DEPLOY: All tools verified!

Deploy to ${params.ENVIRONMENT} using Ansible?
"""
                    if (params.ENVIRONMENT == 'production') {
                        deploymentMessage = """
‚ö†Ô∏è PRODUCTION DEPLOYMENT ‚ö†Ô∏è

‚úÖ All tools verified and ready
üéØ Target: PRODUCTION environment

Are you sure you want to deploy to PRODUCTION?

Build: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}
Method: Ansible automation
"""
                    }
                    
                    def approver = input message: deploymentMessage,
                                        ok: "Deploy to ${params.ENVIRONMENT}",
                                        submitterParameter: 'APPROVER'
                    
                    env.DEPLOYMENT_APPROVER = approver ?: 'unknown'
                    
                    echo "Deployment approved by: ${env.DEPLOYMENT_APPROVER}"
                    echo "Deploying to: ${params.ENVIRONMENT}"
                    echo "Build to deploy: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                    echo "Tool check: ${params.SKIP_TOOL_CHECK ? 'Skipped' : 'Completed'}"
                }
            }
        }
        
        stage('Download Artifact') {
            steps {
                script {
                    cleanWs()
                    
                    def buildNumber = params.BUILD_NUMBER_TO_DEPLOY ?: ''
                    def ciJobName = 'hello-rails'
                    
                    echo "Downloading artifact from: ${ciJobName}"
                    
                    try {
                        if (buildNumber) {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'SpecificBuildSelector', buildNumber: buildNumber],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        } else {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'StatusBuildSelector', stable: false],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        }
                        
                        sh '''
                            if ls hello-world-app-*.tar.gz 1> /dev/null 2>&1; then
                                echo "‚úÖ Artifact files found:"
                                ls -la hello-world-app-*.tar.gz
                            else
                                echo "‚ùå No artifact files found!"
                                exit 1
                            fi
                        '''
                        
                    } catch (Exception e) {
                        error("Failed to download artifact: ${e.message}")
                    }
                }
            }
        }
        
        stage('Setup Ansible Environment') {
            steps {
                script {
                    sh '''
                        echo "=== Setting up Ansible environment ==="
                        
                        # Find Ansible binary
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "‚úÖ Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        echo "$ANSIBLE_BINARY" > /tmp/ansible_path
                        echo "ANSIBLE_DIR=$(dirname $ANSIBLE_BINARY)" > /tmp/ansible_env
                        
                        # Create Ansible structure
                        mkdir -p ansible/{inventories,playbooks}
                        mkdir -p ansible/inventories/staging
                        mkdir -p ansible/inventories/production
                        
                        # Create staging inventory
                        cat > ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=54.210.171.180 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=staging
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create production inventory
                        cat > ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=production
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create Rails deployment playbook using script files
                        cat > ansible/playbooks/deploy.yml << 'DEPLOY_EOF'
---
- name: Deploy Beautiful Rails Application
  hosts: webservers
  become: yes
  vars:
    app_archive_path: "/tmp/{{ app_name }}-{{ build_number | default('latest') }}.tar.gz"
  
  tasks:
    - name: Upload artifact
      shell: |
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no "{{ local_artifact_path }}" deploy@{{ ansible_host }}:/tmp/{{ app_name }}-{{ build_number }}.tar.gz
      delegate_to: localhost
      become: no

    - name: Create directories
      file:
        path: "{{ deploy_path }}/{{ rails_env }}/current"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0755'

    - name: Extract application
      unarchive:
        src: "{{ app_archive_path }}"
        dest: "{{ deploy_path }}/{{ rails_env }}/current"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        remote_src: yes

    - name: Create Rails routes script
      copy:
        dest: /tmp/create_routes.rb
        content: |
          File.open('config/routes.rb', 'w') do |f|
            f.puts "Rails.application.routes.draw do"
            f.puts "  root 'welcome#index'"
            f.puts "  get '/health', to: proc { [200, { 'Content-Type' => 'application/json' }, [{ status: 'ok', environment: Rails.env }.to_json]] }"
            f.puts "end"
          end

    - name: Create Rails controller script
      copy:
        dest: /tmp/create_controller.rb
        content: |
          require 'fileutils'
          FileUtils.mkdir_p('app/controllers')
          File.open('app/controllers/welcome_controller.rb', 'w') do |f|
            f.puts "class WelcomeController < ApplicationController"
            f.puts "  def index"
            f.puts "    @info = {"
            f.puts "      environment: Rails.env,"
            f.puts "      rails_version: Rails.version,"
            f.puts "      ruby_version: RUBY_VERSION,"
            f.puts "      deployed_at: Time.current"
            f.puts "    }"
            f.puts "  end"
            f.puts "end"
          end

    - name: Create Rails layout script
      copy:
        dest: /tmp/create_layout.sh
        mode: '0755'
        content: |
          #!/bin/bash
          mkdir -p app/views/layouts
          cat > app/views/layouts/application.html.erb << 'LAYOUT_END'
          <!DOCTYPE html>
          <html>
            <head>
              <title>Rails Deployment Success</title>
              <meta name="viewport" content="width=device-width,initial-scale=1">
              <style>
                body { font-family: system-ui, sans-serif; margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
                .container { max-width: 1000px; margin: 0 auto; padding: 20px; }
                .header { background: rgba(255,255,255,0.95); padding: 40px; border-radius: 20px; text-align: center; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
                .content { background: rgba(255,255,255,0.95); padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
                .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }
                .card { background: #f8f9fa; padding: 20px; border-radius: 15px; border-left: 4px solid #28a745; }
                .badge { display: inline-block; padding: 6px 12px; border-radius: 15px; font-size: 0.9em; font-weight: bold; margin: 5px; background: #28a745; color: white; }
                h1 { color: #2563eb; margin: 0; font-size: 2.5em; }
                h3 { color: #374151; margin-top: 0; }
                .status { font-size: 1.3em; color: #28a745; margin: 20px 0; }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="header">
                  <h1>üöÄ Rails Deployment Success!</h1>
                  <p class="status">‚úÖ Application Successfully Deployed</p>
                </div>
                <div class="content">
                  <%= yield %>
                </div>
              </div>
            </body>
          </html>
          LAYOUT_END

    - name: Create Rails view script
      copy:
        dest: /tmp/create_view.sh
        mode: '0755'
        content: |
          #!/bin/bash
          mkdir -p app/views/welcome
          cat > app/views/welcome/index.html.erb << 'VIEW_END'
          <div class="grid">
            <div class="card">
              <h3>üéØ Deployment Info</h3>
              <% if @info %>
                <p><strong>Environment:</strong> <%= @info[:environment].upcase %></p>
                <p><strong>Deployed:</strong> <%= @info[:deployed_at].strftime("%B %d, %Y at %I:%M %p") %></p>
              <% end %>
            </div>
            
            <div class="card">
              <h3>üõ†Ô∏è Tech Stack</h3>
              <p><strong>Rails:</strong> <%= Rails.version %></p>
              <p><strong>Ruby:</strong> <%= RUBY_VERSION %></p>
              <p><strong>Environment:</strong> <%= Rails.env %></p>
            </div>
            
            <div class="card">
              <h3>üìä Status</h3>
              <p>‚úÖ Rails Server Running</p>
              <p>‚úÖ Database Connected</p>
              <p>‚úÖ Ready to Serve</p>
            </div>
          </div>

          <div style="text-align: center; margin-top: 30px; padding: 20px; background: #e8f5e8; border-radius: 15px;">
            <h3>üéâ CI/CD Success!</h3>
            <p>Deployed with Jenkins and Ansible automation</p>
            <span class="badge">Tool Verification</span>
            <span class="badge">Rails Deployment</span>
            <span class="badge">Beautiful UI</span>
          </div>
          VIEW_END

    - name: Setup Rails with beautiful UI
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        echo "üé® Setting up beautiful Rails application..."
        
        # Ruby environment
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        # Install gems
        bundle install --without development test
        
        # Create Rails components using scripts
        ruby /tmp/create_routes.rb
        ruby /tmp/create_controller.rb
        bash /tmp/create_layout.sh
        bash /tmp/create_view.sh
        
        echo "‚úÖ Beautiful Rails UI components created"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"

    - name: Database operations
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo "üóÑÔ∏è Database operations..."
        
        # Database setup
        RAILS_ENV={{ rails_env }} bundle exec rake db:create 2>/dev/null || echo "Database exists"
        RAILS_ENV={{ rails_env }} bundle exec rake db:migrate
        RAILS_ENV={{ rails_env }} bundle exec rake assets:precompile
        
        echo "‚úÖ Database operations completed"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"
        RAILS_ENV: "{{ rails_env }}"

    - name: Start Rails server
      shell: |
        # Stop existing servers
        pkill -f 'python.*http.server' || true
        pkill -f 'rails server' || true
        sleep 5
        
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo "üöÄ Starting beautiful Rails application..."
        
        # Start Rails server
        nohup bundle exec rails server -e {{ rails_env }} -p 3000 -b 0.0.0.0 > log/rails.log 2>&1 &
        echo $! > tmp/pids/server.pid
        
        sleep 15
        
        if ps aux | grep -v grep | grep 'rails server'; then
          echo "‚úÖ Beautiful Rails UI started successfully"
        else
          echo "‚ùå Rails server failed to start"
          tail -20 log/rails.log
          exit 1
        fi
      become_user: "{{ deploy_user }}"

    - name: Verify deployment
      shell: |
        echo "üîç VERIFYING BEAUTIFUL RAILS DEPLOYMENT"
        echo "========================================"
        
        # Check server
        if ps aux | grep -v grep | grep 'rails server'; then
          echo "‚úÖ Rails server running"
        fi
        
        if netstat -tlnp | grep :3000; then
          echo "‚úÖ Port 3000 listening"
        fi
        
        # Test UI
        if curl -s http://localhost:3000 | grep -i "deployment.*success"; then
          echo "‚úÖ Beautiful Rails UI confirmed"
        fi
        
        echo "üé® Beautiful UI live at: http://{{ ansible_host }}:3000"
      become_user: "{{ deploy_user }}"
      ignore_errors: yes

    - name: Success message
      debug:
        msg: |
          üéâ BEAUTIFUL RAILS UI DEPLOYMENT SUCCESS! üéâ
          
          ‚ú® Your stunning Rails application is now live!
          üåç Access: http://{{ ansible_host }}:3000/
          üè• Health: http://{{ ansible_host }}:3000/health
          
          Features deployed:
          ‚úÖ Modern responsive design
          ‚úÖ Deployment dashboard
          ‚úÖ Technical stack display
          ‚úÖ Status indicators
DEPLOY_EOF
                        
                        echo "‚úÖ Ansible deployment structure created"
                    '''
                }
            }
        }
        
        stage('Prepare Deployment') {
            steps {
                script {
                    sh '''
                        # Get artifact info
                        ARTIFACT_FILE=$(ls hello-world-app-*.tar.gz | head -1)
                        BUILD_NUM=$(echo $ARTIFACT_FILE | sed 's/hello-world-app-//; s/.tar.gz//')
                        
                        echo "Artifact: $ARTIFACT_FILE"
                        echo "Build number: $BUILD_NUM"
                        
                        # Create variables file
                        cat > ansible/extra_vars.yml << EOF
build_number: ${BUILD_NUM}
app_archive_path: /tmp/hello-world-app-${BUILD_NUM}.tar.gz
local_artifact_path: $(pwd)/${ARTIFACT_FILE}
environment: ${ENVIRONMENT}
deployed_by: ${DEPLOYMENT_APPROVER}
deployed_at: $(date)
EOF
                        
                        echo "=== Deployment Variables ==="
                        cat ansible/extra_vars.yml
                    '''
                }
            }
        }
        
        stage('Test Ansible Connectivity') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            
                            echo "Testing connectivity..."
                            $ANSIBLE_BINARY -i inventories/${ENVIRONMENT}/hosts webservers -m ping
                            
                            if [ $? -eq 0 ]; then
                                echo "‚úÖ Connectivity test passed"
                            else
                                echo "‚ùå Connectivity test failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deploy Beautiful Rails Application') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                            
                            echo "üöÄ Deploying beautiful Rails application..."
                            
                            $ANSIBLE_PLAYBOOK_BINARY -i inventories/${ENVIRONMENT}/hosts playbooks/deploy.yml \\
                                --extra-vars @extra_vars.yml \\
                                -v
                            
                            if [ $? -eq 0 ]; then
                                echo "‚úÖ Beautiful Rails UI deployed successfully!"
                            else
                                echo "‚ùå Deployment failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Post-Deployment Verification') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "üè• Verifying beautiful Rails UI..."
                            
                            sleep 25
                            
                            MAX_RETRIES=10
                            RETRY_COUNT=0
                            
                            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                                echo "Verification attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
                                
                                if curl -f -s -o /dev/null http://${EC2_HOST}:3000/; then
                                    echo "‚úÖ Beautiful Rails UI is live!"
                                    break
                                else
                                    echo "‚è≥ Waiting for UI..."
                                    sleep 10
                                    RETRY_COUNT=$((RETRY_COUNT + 1))
                                fi
                            done
                            
                            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                                echo "‚ùå UI verification failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deployment Summary') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "
üéâ BEAUTIFUL RAILS UI DEPLOYMENT SUCCESS! üéâ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä Deployment Details:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Environment: ${ENVIRONMENT}
Server: ${EC2_HOST}
Approved by: ${DEPLOYMENT_APPROVER}
Build: ${BUILD_NUMBER_TO_DEPLOY:-latest}
Type: ‚ú® Beautiful Modern Rails UI
URL: http://${EC2_HOST}:3000
Time: $(date)

üé® UI Features Deployed:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ú® Modern gradient background
‚ú® Glassmorphism cards
‚ú® Responsive design
‚ú® Deployment dashboard
‚ú® Technical stack display
‚ú® Status indicators

üöÄ Rails Operations:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ RAILS_ENV=${ENVIRONMENT} rake db:create
‚úÖ RAILS_ENV=${ENVIRONMENT} rake db:migrate
‚úÖ RAILS_ENV=${ENVIRONMENT} rake assets:precompile
‚úÖ Beautiful UI components created
‚úÖ Rails server started

üîó Access Your Beautiful Application:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üåç Main UI: http://${EC2_HOST}:3000/
üè• Health: http://${EC2_HOST}:3000/health
üîß SSH: ssh deploy@${EC2_HOST}

üéØ SUCCESS: Beautiful Rails UI is now live!
                            "
                        '''
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "‚úÖ Beautiful Rails UI deployment completed successfully!"
        }
        
        failure {
            echo "‚ùå Deployment failed!"
        }
        
        always {
            script {
                sh '''
                    rm -f hello-world-app-*.tar.gz
                    rm -f ansible/extra_vars.yml
                    rm -rf temp_ansible
                '''
            }
            cleanWs()
        }
    }
}