pipeline {
    agent any
    
    environment {
        // Branch to server mapping - simplified for single staging server
        DEV1_BRANCH = 'dev1'
        DEV2_BRANCH = 'dev2'
        DEV3_BRANCH = 'dev3'
        STAGING1_BRANCH = 'staging1'
        
        ANSIBLE_PLAYBOOK = 'ansible/deploy.yml'
    }
    
    stages {
        stage('Checkout & Branch Detection') {
            steps {
                checkout scm
                script {
                    // Get branch name from Jenkins environment variables
                    if (env.BRANCH_NAME) {
                        // Multibranch pipeline
                        env.DETECTED_BRANCH = env.BRANCH_NAME
                    } else if (env.GIT_BRANCH) {
                        // Regular pipeline with Git plugin
                        env.DETECTED_BRANCH = env.GIT_BRANCH.replaceFirst(/^origin\//, '')
                    } else {
                        // Fallback: try to detect from git
                        def branchName = sh(
                            script: "git branch -r --contains HEAD | grep origin | head -1 | sed 's/.*origin\\///'",
                            returnStdout: true
                        ).trim()
                        env.DETECTED_BRANCH = branchName
                    }
                    
                    echo "‚úÖ Detected branch: ${env.DETECTED_BRANCH}"
                }
            }
        }
        
        stage('Determine Target Server & Credentials') {
            steps {
                script {
                    // Map branch to server and credentials
                    switch(env.DETECTED_BRANCH) {
                        // Development servers (using simplified approach)
                        case DEV1_BRANCH:
                            env.TARGET_SERVER = 'dev1-server'
                            env.RAILS_ENV = 'development1'
                            env.ANSIBLE_LIMIT = 'dev1_servers'
                            env.ANSIBLE_INVENTORY = 'inventory/dev/hosts'
                            env.ENVIRONMENT_TYPE = 'development'
                            // For dev servers, we'll use simple credentials in inventory
                            env.USE_JENKINS_CREDS = 'false'
                            break
                        case DEV2_BRANCH:
                            env.TARGET_SERVER = 'dev2-server'
                            env.RAILS_ENV = 'development2'
                            env.ANSIBLE_LIMIT = 'dev2_servers'
                            env.ANSIBLE_INVENTORY = 'inventory/dev/hosts'
                            env.ENVIRONMENT_TYPE = 'development'
                            env.USE_JENKINS_CREDS = 'false'
                            break
                        case DEV3_BRANCH:
                            env.TARGET_SERVER = 'dev3-server'
                            env.RAILS_ENV = 'development3'
                            env.ANSIBLE_LIMIT = 'dev3_servers'
                            env.ANSIBLE_INVENTORY = 'inventory/dev/hosts'
                            env.ENVIRONMENT_TYPE = 'development'
                            env.USE_JENKINS_CREDS = 'false'
                            break
                        
                        // Staging server (using Jenkins credentials)
                        case STAGING1_BRANCH:
                            env.TARGET_SERVER = 'staging1-server'
                            env.RAILS_ENV = 'staging1'
                            env.ANSIBLE_LIMIT = 'staging1_servers'
                            env.ANSIBLE_INVENTORY = 'inventory/staging/hosts'
                            env.ENVIRONMENT_TYPE = 'staging'
                            env.USE_JENKINS_CREDS = 'true'
                            // Your actual Jenkins credential IDs
                            env.DB_USERNAME_ID = 'ec2-db-username'
                            env.DB_PASSWORD_ID = 'ec2-db-password'
                            env.DB_URL_ID = 'ec2-staging-database-url'
                            env.STAGING_HOST_ID = 'ec2-staging-host'
                            env.SSH_KEY_ID = 'ec2-ssh-key'
                            env.RAILS_SECRET_ID = 'rails-secret-staging'
                            break
                        
                        default:
                            error("‚ùå Branch '${env.DETECTED_BRANCH}' is not configured for deployment. Configured branches: dev1, dev2, dev3, staging1")
                    }
                    
                    echo "üöÄ Deployment Configuration:"
                    echo "Branch: ${env.DETECTED_BRANCH}"
                    echo "Target server: ${env.TARGET_SERVER}"
                    echo "Rails environment: ${env.RAILS_ENV}"
                    echo "Environment type: ${env.ENVIRONMENT_TYPE}"
                    echo "Use Jenkins credentials: ${env.USE_JENKINS_CREDS}"
                    if (env.USE_JENKINS_CREDS == 'true') {
                        echo "DB Username ID: ${env.DB_USERNAME_ID}"
                        echo "DB Password ID: ${env.DB_PASSWORD_ID}"
                        echo "DB URL ID: ${env.DB_URL_ID}"
                        echo "Staging Host ID: ${env.STAGING_HOST_ID}"
                        echo "SSH Key ID: ${env.SSH_KEY_ID}"
                    }
                }
            }
        }
        
        stage('Build & Test') {
            steps {
                script {
                    echo "üß™ Running tests for ${env.DETECTED_BRANCH}"
                    // Add your build and test steps here if needed
                    // sh 'bundle install'
                    // sh 'bundle exec rspec'
                }
            }
        }
        
        stage('Deploy to Development Server') {
            when {
                expression { env.USE_JENKINS_CREDS == 'false' }
            }
            steps {
                script {
                    echo "üîÑ Deploying branch '${env.DETECTED_BRANCH}' to ${env.TARGET_SERVER} (Development)"
                    
                    // Deploy to dev servers without Jenkins credentials
                    // Database credentials are stored in inventory files
                    sh """
                        ansible-playbook -i ${env.ANSIBLE_INVENTORY} \
                                       --limit ${env.ANSIBLE_LIMIT} \
                                       --extra-vars "rails_env=${env.RAILS_ENV} \
                                                    branch_name=${env.DETECTED_BRANCH} \
                                                    environment_type=${env.ENVIRONMENT_TYPE}" \
                                       ${ANSIBLE_PLAYBOOK}
                    """
                }
            }
        }
        
        stage('Deploy to Staging Server') {
            when {
                expression { env.USE_JENKINS_CREDS == 'true' }
            }
            steps {
                withCredentials([
                    string(
                        credentialsId: env.DB_USERNAME_ID,
                        variable: 'DB_USERNAME'
                    ),
                    string(
                        credentialsId: env.DB_PASSWORD_ID,
                        variable: 'DB_PASSWORD'
                    ),
                    string(
                        credentialsId: env.DB_URL_ID,
                        variable: 'DB_URL'
                    ),
                    string(
                        credentialsId: env.STAGING_HOST_ID,
                        variable: 'STAGING_HOST'
                    ),
                    string(
                        credentialsId: env.RAILS_SECRET_ID,
                        variable: 'RAILS_SECRET'
                    ),
                    sshUserPrivateKey(
                        credentialsId: env.SSH_KEY_ID,
                        keyFileVariable: 'SSH_KEY_FILE',
                        usernameVariable: 'SSH_USER'
                    )
                ]) {
                    script {
                        echo "üîÑ Deploying branch '${env.DETECTED_BRANCH}' to ${env.TARGET_SERVER} (Staging)"
                        echo "üìã Using Jenkins credentials for staging deployment"
                        echo "üñ•Ô∏è Target host: \${STAGING_HOST}"
                        echo "üë§ DB user: \${DB_USERNAME}"
                        
                        // Deploy to staging server with Jenkins credentials
                        sh """
                            ansible-playbook -i ${env.ANSIBLE_INVENTORY} \
                                           --limit ${env.ANSIBLE_LIMIT} \
                                           --private-key \${SSH_KEY_FILE} \
                                           --extra-vars "rails_env=${env.RAILS_ENV} \
                                                        branch_name=${env.DETECTED_BRANCH} \
                                                        environment_type=${env.ENVIRONMENT_TYPE} \
                                                        db_username=\${DB_USERNAME} \
                                                        db_password=\${DB_PASSWORD} \
                                                        db_url=\${DB_URL} \
                                                        staging_host=\${STAGING_HOST} \
                                                        rails_secret=\${RAILS_SECRET}" \
                                           ${ANSIBLE_PLAYBOOK}
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo "‚úÖ SUCCESS: Branch '${env.DETECTED_BRANCH}' deployed successfully to ${env.TARGET_SERVER}"
                echo "üéØ Rails Environment: ${env.RAILS_ENV}"
                echo "üèóÔ∏è Environment Type: ${env.ENVIRONMENT_TYPE}"
                
                // Optional: Send success notification
                // slackSend(
                //     channel: '#deployments',
                //     color: 'good',
                //     message: "‚úÖ Deployment Success: ${env.DETECTED_BRANCH} ‚Üí ${env.TARGET_SERVER} (${env.RAILS_ENV})"
                // )
            }
        }
        failure {
            script {
                echo "‚ùå FAILED: Deployment of branch '${env.DETECTED_BRANCH}' to ${env.TARGET_SERVER} failed"
                
                // Optional: Send failure notification
                // slackSend(
                //     channel: '#deployments',
                //     color: 'danger',
                //     message: "‚ùå Deployment Failed: ${env.DETECTED_BRANCH} ‚Üí ${env.TARGET_SERVER} (${env.RAILS_ENV})"
                // )
            }
        }
        always {
            cleanWs()
        }
    }
}