pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['staging', 'production'],
            description: 'Select deployment environment'
        )
        string(
            name: 'BUILD_NUMBER_TO_DEPLOY',
            defaultValue: '',
            description: 'Build number from CI pipeline to deploy (leave empty for latest)'
        )
    }
    
    environment {
        APP_NAME = 'hello-world-app'
        DEPLOY_USER = 'deploy'
        DEPLOY_PATH = '/var/www/hello-world-app'
    }
    
    stages {
        stage('Manual Approval') {
            steps {
                script {
                    def deploymentMessage = "Deploy to ${params.ENVIRONMENT}?"
                    if (params.ENVIRONMENT == 'production') {
                        deploymentMessage = "âš ï¸ PRODUCTION DEPLOYMENT âš ï¸\n\nAre you sure you want to deploy to PRODUCTION?\n\nBuild: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                    }
                    
                    def approver = input message: deploymentMessage,
                                        ok: "Deploy to ${params.ENVIRONMENT}",
                                        submitterParameter: 'APPROVER'
                    
                    env.DEPLOYMENT_APPROVER = approver ?: 'unknown'
                    
                    echo "Deployment approved by: ${env.DEPLOYMENT_APPROVER}"
                    echo "Deploying to: ${params.ENVIRONMENT}"
                    echo "Build to deploy: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                }
            }
        }
        
        stage('Download Artifact') {
            steps {
                script {
                    cleanWs()
                    
                    def buildNumber = params.BUILD_NUMBER_TO_DEPLOY ?: ''
                    def ciJobName = 'hello-rails'
                    
                    echo "Downloading artifact from: ${ciJobName}"
                    echo "Build number: ${buildNumber ?: 'latest successful'}"
                    
                    try {
                        if (buildNumber) {
                            // Copy artifact from specific build
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'SpecificBuildSelector', buildNumber: buildNumber],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                            echo "âœ… Artifact downloaded from build ${buildNumber}"
                        } else {
                            // Copy artifact from latest successful build
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'StatusBuildSelector', stable: false],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                            echo "âœ… Artifact downloaded from latest successful build"
                        }
                        
                        // Verify artifact was downloaded
                        sh '''
                            if ls hello-world-app-*.tar.gz 1> /dev/null 2>&1; then
                                echo "âœ… Artifact files found:"
                                ls -la hello-world-app-*.tar.gz
                            else
                                echo "âŒ No artifact files found!"
                                echo "Available files:"
                                ls -la
                                exit 1
                            fi
                        '''
                        
                    } catch (Exception e) {
                        echo "âŒ Failed to download artifact: ${e.message}"
                        echo "Make sure:"
                        echo "1. Copy Artifact Plugin is installed"
                        echo "2. CI job name is correct: ${ciJobName}"
                        echo "3. CI job has successfully created artifacts"
                        error("Artifact download failed: ${e.message}")
                    }
                }
            }
        }
        
        stage('Deploy to EC2') {
            steps {
                script {
                    withCredentials([
                        sshUserPrivateKey(
                            credentialsId: 'ec2-ssh-key',
                            keyFileVariable: 'SSH_KEY',
                            usernameVariable: 'SSH_USER'
                        ),
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST'),
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-database-url", variable: 'DATABASE_URL')
                    ]) {
                        sh '''
                            # Get artifact info
                            ARTIFACT_FILE=$(ls hello-world-app-*.tar.gz | head -1)
                            echo "Deploying: $ARTIFACT_FILE"
                            
                            # Create release directory name
                            RELEASE_DIR="${DEPLOY_PATH}/${ENVIRONMENT}/releases/$(date +%Y%m%d%H%M%S)"
                            CURRENT_DIR="${DEPLOY_PATH}/${ENVIRONMENT}/current"
                            
                            echo "Release directory: $RELEASE_DIR"
                            echo "Current directory: $CURRENT_DIR"
                            
                            # Create directories on EC2
                            ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$EC2_HOST "
                                sudo mkdir -p $RELEASE_DIR
                                sudo mkdir -p ${DEPLOY_PATH}/${ENVIRONMENT}/shared/{log,tmp,config}
                                sudo chown -R ubuntu:ubuntu ${DEPLOY_PATH}
                            "
                            
                            # Upload and extract application
                            scp -i $SSH_KEY -o StrictHostKeyChecking=no $ARTIFACT_FILE $SSH_USER@$EC2_HOST:/tmp/
                            
                            ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$EC2_HOST "
                                # Change to release directory and set ownership
                                sudo chown -R deploy:deploy $RELEASE_DIR
                                cd $RELEASE_DIR
                                
                                # Extract application files
                                tar -xzf /tmp/$ARTIFACT_FILE --strip-components=1
                                
                                # Set proper ownership after extraction
                                sudo chown -R deploy:deploy $RELEASE_DIR
                                
                                # Check if rbenv is installed, if not install it
                                if [ ! -d ~/.rbenv ]; then
                                    echo 'Installing rbenv...'
                                    git clone https://github.com/rbenv/rbenv.git ~/.rbenv
                                    git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build
                                    echo 'export PATH=~/.rbenv/bin:$PATH' >> ~/.bashrc
                                    echo 'eval $(rbenv init -)' >> ~/.bashrc
                                fi
                                
                                # Setup Ruby environment
                                export PATH=~/.rbenv/bin:$PATH
                                eval $(rbenv init - 2>/dev/null) || true
                                
                                # Install Ruby if not present
                                if ! rbenv versions | grep -q 3.1.3; then
                                    echo 'Installing Ruby 3.1.3...'
                                    rbenv install 3.1.3
                                    rbenv global 3.1.3
                                    gem install bundler
                                fi
                                
                                rbenv global 3.1.3 2>/dev/null || true
                                
                                # Generate Rails secret key
                                if command -v bundle >/dev/null 2>&1; then
                                    GENERATED_SECRET=\$(bundle exec rails secret 2>/dev/null || ruby -e \"require 'securerandom'; puts SecureRandom.hex(64)\")
                                else
                                    GENERATED_SECRET=\$(ruby -e \"require 'securerandom'; puts SecureRandom.hex(64)\" 2>/dev/null || echo 'fallback_secret_key_$(date +%s)')
                                fi
                                
                                # Create environment file
                                cat > .env.${ENVIRONMENT} << 'EOL'
RAILS_ENV=${ENVIRONMENT}
DATABASE_URL=${DATABASE_URL}
SECRET_KEY_BASE=\$GENERATED_SECRET
RAILS_LOG_TO_STDOUT=true
RAILS_SERVE_STATIC_FILES=true
EOL
                                
                                echo 'Generated Rails secret key for ${ENVIRONMENT}'
                                
                                # Install system dependencies if needed
                                if ! dpkg -l | grep -q build-essential; then
                                    sudo apt update
                                    sudo apt install -y build-essential libssl-dev libreadline-dev zlib1g-dev
                                fi
                                
                                # Try to install gems
                                if command -v bundle >/dev/null 2>&1; then
                                    echo 'Installing gems...'
                                    bundle install --deployment --without development test 2>/dev/null || bundle install --without development test
                                else
                                    echo 'Bundler not available, trying with gem install'
                                    gem install rails
                                fi
                                
                                # Create symlinks
                                ln -sfn ${DEPLOY_PATH}/${ENVIRONMENT}/shared/log log 2>/dev/null || true
                                ln -sfn ${DEPLOY_PATH}/${ENVIRONMENT}/shared/tmp tmp 2>/dev/null || true
                                
                                # Try database operations
                                if [ -f .env.${ENVIRONMENT} ]; then
                                    source .env.${ENVIRONMENT}
                                    if command -v bundle >/dev/null 2>&1; then
                                        echo 'Running database migrations...'
                                        bundle exec rake db:create 2>/dev/null || echo 'Database creation skipped'
                                        bundle exec rake db:migrate 2>/dev/null || echo 'Database migration skipped'
                                    fi
                                fi
                                
                                # Try asset precompilation
                                if command -v bundle >/dev/null 2>&1; then
                                    echo 'Precompiling assets...'
                                    bundle exec rake assets:precompile 2>/dev/null || echo 'Asset precompilation skipped'
                                fi
                                
                                # Update current symlink
                                sudo ln -sfn $RELEASE_DIR $CURRENT_DIR
                                
                                # Try to start Rails server
                                pkill -f 'rails server' 2>/dev/null || true
                                cd $CURRENT_DIR
                                
                                if command -v bundle >/dev/null 2>&1 && [ -f Gemfile ]; then
                                    echo 'Starting Rails server...'
                                    nohup bundle exec rails server -e ${ENVIRONMENT} -p 3000 > log/rails.log 2>&1 &
                                    echo 'Rails server started on port 3000'
                                else
                                    echo 'Starting simple Ruby server...'
                                    nohup ruby -run -e httpd . -p 3000 > /tmp/server.log 2>&1 &
                                    echo 'Simple server started on port 3000'
                                fi
                                
                                # Cleanup old releases (keep last 5)
                                cd ${DEPLOY_PATH}/${ENVIRONMENT}/releases 2>/dev/null || true
                                ls -t 2>/dev/null | tail -n +6 | xargs -r sudo rm -rf
                                
                                echo 'Deployment completed successfully!'
                            "
                            
                            # Clean up local artifact
                            rm -f /tmp/$ARTIFACT_FILE
                        '''
                    }
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "Waiting for application to start..."
                            sleep 20
                            
                            # Check if application is responding
                            MAX_RETRIES=10
                            RETRY_COUNT=0
                            
                            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                                echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
                                
                                if curl -f -s -o /dev/null http://${EC2_HOST}:3000/health || curl -f -s -o /dev/null http://${EC2_HOST}:3000/; then
                                    echo "âœ… Application is responding!"
                                    break
                                else
                                    echo "â³ Application not ready, retrying in 10 seconds..."
                                    sleep 10
                                    RETRY_COUNT=$((RETRY_COUNT + 1))
                                fi
                            done
                            
                            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                                echo "âŒ Health check failed after $MAX_RETRIES attempts"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deployment Summary') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "
ðŸŽ‰ Deployment Summary:
================================
Environment: ${ENVIRONMENT}
Server: ${EC2_HOST}
Approved by: ${DEPLOYMENT_APPROVER}
Build: ${BUILD_NUMBER_TO_DEPLOY:-latest}
Application URL: http://${EC2_HOST}:3000
Deployment time: $(date)
================================
                            "
                        '''
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "âœ… Deployment to ${params.ENVIRONMENT} completed successfully!"
            
            // Optional: Send success notification
            script {
                try {
                    withCredentials([
                        string(credentialsId: 'slack-webhook-url', variable: 'SLACK_WEBHOOK')
                    ]) {
                        sh '''
                            curl -X POST -H 'Content-type: application/json' \
                                --data '{"text":"âœ… Deployment Success: '${APP_NAME}' to '${ENVIRONMENT}' - Build #'${BUILD_NUMBER}' (by '${DEPLOYMENT_APPROVER}')"}' \
                                $SLACK_WEBHOOK
                        '''
                    }
                } catch (Exception e) {
                    echo "Notification failed: ${e.message}"
                }
            }
        }
        
        failure {
            echo "âŒ Deployment to ${params.ENVIRONMENT} failed!"
            
            // Optional: Rollback logic
            script {
                try {
                    withCredentials([
                        sshUserPrivateKey(
                            credentialsId: 'ec2-ssh-key',
                            keyFileVariable: 'SSH_KEY',
                            usernameVariable: 'SSH_USER'
                        ),
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "Attempting rollback to previous release..."
                            ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$EC2_HOST "
                                cd ${DEPLOY_PATH}/${ENVIRONMENT}/releases
                                PREVIOUS_RELEASE=\\$(ls -t | sed -n 2p)
                                if [ -n \\"\\$PREVIOUS_RELEASE\\" ]; then
                                    ln -sfn ${DEPLOY_PATH}/${ENVIRONMENT}/releases/\\$PREVIOUS_RELEASE ${DEPLOY_PATH}/${ENVIRONMENT}/current
                                    echo \\"Rolled back to: \\$PREVIOUS_RELEASE\\"
                                    
                                    # Restart application
                                    cd ${DEPLOY_PATH}/${ENVIRONMENT}/current
                                    export PATH=\\"\\$HOME/.rbenv/bin:\\$PATH\\"
                                    eval \\"\\$(rbenv init -)\\"
                                    source .env.${ENVIRONMENT}
                                    pkill -f 'rails server' || true
                                    nohup bundle exec rails server -e ${ENVIRONMENT} -p 3000 > log/rails.log 2>&1 &
                                else
                                    echo \\"No previous release found for rollback\\"
                                fi
                            "
                        '''
                    }
                } catch (Exception e) {
                    echo "Rollback failed: ${e.message}"
                }
            }
        }
        
        always {
            cleanWs()
        }
    }
}