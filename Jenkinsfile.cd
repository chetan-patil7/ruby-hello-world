pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['staging', 'production'],
            description: 'Select deployment environment'
        )
        string(
            name: 'BUILD_NUMBER_TO_DEPLOY',
            defaultValue: '',
            description: 'Build number from CI pipeline to deploy (leave empty for latest)'
        )
        booleanParam(
            name: 'FORCE_TOOL_INSTALLATION',
            defaultValue: false,
            description: 'Force reinstallation of all tools (even if already installed)'
        )
        booleanParam(
            name: 'SKIP_TOOL_CHECK',
            defaultValue: false,
            description: 'Skip tool verification and installation (use only if tools are confirmed to be installed)'
        )
    }
    
    environment {
        APP_NAME = 'hello-world-app'
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_STDOUT_CALLBACK = 'yaml'
    }
    
    stages {
        stage('Initial Server Tool Verification') {
            when {
                expression { !params.SKIP_TOOL_CHECK }
            }
            steps {
                script {
                    sh '''
                        echo "üîç INITIAL SERVER TOOL VERIFICATION"
                        echo "====================================="
                        echo "Environment: ${ENVIRONMENT}"
                        echo "Force installation: ${FORCE_TOOL_INSTALLATION}"
                        echo ""
                        
                        # Create temporary Ansible structure for tool checking
                        mkdir -p temp_ansible/{inventories,playbooks}
                        mkdir -p temp_ansible/inventories/staging
                        mkdir -p temp_ansible/inventories/production
                        
                        # Create inventory files
                        cat > temp_ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=3.237.64.25 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        cat > temp_ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
deploy_user=deploy
EOF

                        # Create comprehensive tool verification playbook
                        cat > temp_ansible/playbooks/verify_and_install_tools.yml << 'EOF'
---
- name: Comprehensive Server Tool Verification and Installation
  hosts: webservers
  become: yes
  vars:
    force_installation: "{{ force_tool_installation | default(false) }}"
    required_tools:
      ruby_version: "3.1.3"
      bundler_version: "2.3.0"
      node_version: "18.x"
      postgres_version: "14"
    
    system_packages:
      - curl
      - wget
      - git
      - build-essential
      - libssl-dev
      - libreadline-dev
      - zlib1g-dev
      - libyaml-dev
      - libxml2-dev
      - libxslt1-dev
      - libcurl4-openssl-dev
      - libffi-dev
      - postgresql
      - postgresql-contrib
      - libpq-dev
      - nodejs
      - npm
      - python3
      - python3-pip
      - unzip
      - htop
      - tree
      - vim
      - redis-server
      - imagemagick
      - libmagickwand-dev
  
  tasks:
    - name: Comprehensive Tool Audit
      shell: |
        echo "üîç COMPREHENSIVE SERVER TOOL AUDIT"
        echo "=================================="
        echo "Date: $(date)"
        echo "Server: $(hostname)"
        echo "User: $(whoami)"
        echo ""
        
        # Initialize tracking variables
        MISSING_PACKAGES=""
        MISSING_TOOLS=""
        INSTALL_REQUIRED=false
        
        echo "üì¶ SYSTEM PACKAGES AUDIT:"
        echo "========================"
        for pkg in curl wget git build-essential postgresql nodejs python3 unzip redis-server imagemagick; do
          if dpkg -l | grep -q "^ii.*$pkg "; then
            echo "  ‚úÖ $pkg - installed"
          else
            echo "  ‚ùå $pkg - MISSING"
            MISSING_PACKAGES="$MISSING_PACKAGES $pkg"
            INSTALL_REQUIRED=true
          fi
        done
        
        echo ""
        echo "üíé RUBY ENVIRONMENT AUDIT:"
        echo "========================="
        
        # Check rbenv
        if [ -d "/home/{{ deploy_user }}/.rbenv" ]; then
          echo "  ‚úÖ rbenv - installed at /home/{{ deploy_user }}/.rbenv"
        else
          echo "  ‚ùå rbenv - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS rbenv"
          INSTALL_REQUIRED=true
        fi
        
        # Check Ruby
        if command -v ruby >/dev/null 2>&1; then
          RUBY_VERSION=$(ruby --version)
          echo "  ‚úÖ Ruby - $RUBY_VERSION"
          if echo "$RUBY_VERSION" | grep -q "{{ required_tools.ruby_version }}"; then
            echo "    ‚úÖ Required version {{ required_tools.ruby_version }} detected"
          else
            echo "    ‚ö†Ô∏è  Version mismatch - required: {{ required_tools.ruby_version }}"
            MISSING_TOOLS="$MISSING_TOOLS ruby-version"
            INSTALL_REQUIRED=true
          fi
        else
          echo "  ‚ùå Ruby - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS ruby"
          INSTALL_REQUIRED=true
        fi
        
        # Check Bundler
        if command -v bundle >/dev/null 2>&1; then
          BUNDLER_VERSION=$(bundle --version)
          echo "  ‚úÖ Bundler - $BUNDLER_VERSION"
        else
          echo "  ‚ùå Bundler - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS bundler"
          INSTALL_REQUIRED=true
        fi
        
        echo ""
        echo "üü¢ NODE.JS ENVIRONMENT AUDIT:"
        echo "============================"
        
        # Check Node.js
        if command -v node >/dev/null 2>&1; then
          NODE_VERSION=$(node --version)
          echo "  ‚úÖ Node.js - $NODE_VERSION"
          if echo "$NODE_VERSION" | grep -q "v18"; then
            echo "    ‚úÖ Compatible version detected"
          else
            echo "    ‚ö†Ô∏è  Version mismatch - recommended: v18.x"
          fi
        else
          echo "  ‚ùå Node.js - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS nodejs"
          INSTALL_REQUIRED=true
        fi
        
        # Check npm
        if command -v npm >/dev/null 2>&1; then
          NPM_VERSION=$(npm --version)
          echo "  ‚úÖ npm - $NPM_VERSION"
        else
          echo "  ‚ùå npm - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS npm"
          INSTALL_REQUIRED=true
        fi
        
        echo ""
        echo "üêò POSTGRESQL AUDIT:"
        echo "==================="
        
        # Check PostgreSQL client
        if command -v psql >/dev/null 2>&1; then
          PSQL_VERSION=$(psql --version)
          echo "  ‚úÖ PostgreSQL client - $PSQL_VERSION"
        else
          echo "  ‚ùå PostgreSQL client - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS postgresql-client"
          INSTALL_REQUIRED=true
        fi
        
        # Check PostgreSQL service
        if systemctl is-active postgresql >/dev/null 2>&1; then
          echo "  ‚úÖ PostgreSQL service - RUNNING"
        elif systemctl is-enabled postgresql >/dev/null 2>&1; then
          echo "  ‚ö†Ô∏è  PostgreSQL service - installed but not running"
        else
          echo "  ‚ùå PostgreSQL service - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS postgresql-service"
          INSTALL_REQUIRED=true
        fi
        
        # Check for deploy user in PostgreSQL
        if command -v psql >/dev/null 2>&1 && systemctl is-active postgresql >/dev/null 2>&1; then
          if sudo -u postgres psql -c "\\du" | grep -q "{{ deploy_user }}"; then
            echo "  ‚úÖ PostgreSQL user '{{ deploy_user }}' - exists"
          else
            echo "  ‚ùå PostgreSQL user '{{ deploy_user }}' - NOT CREATED"
            MISSING_TOOLS="$MISSING_TOOLS postgresql-user"
            INSTALL_REQUIRED=true
          fi
        fi
        
        echo ""
        echo "üêç PYTHON ENVIRONMENT AUDIT:"
        echo "==========================="
        
        # Check Python3
        if command -v python3 >/dev/null 2>&1; then
          PYTHON_VERSION=$(python3 --version)
          echo "  ‚úÖ Python3 - $PYTHON_VERSION"
        else
          echo "  ‚ùå Python3 - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS python3"
          INSTALL_REQUIRED=true
        fi
        
        # Check pip3
        if command -v pip3 >/dev/null 2>&1; then
          PIP_VERSION=$(pip3 --version)
          echo "  ‚úÖ pip3 - $PIP_VERSION"
        else
          echo "  ‚ùå pip3 - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS pip3"
          INSTALL_REQUIRED=true
        fi
        
        echo ""
        echo "üîß ADDITIONAL TOOLS AUDIT:"
        echo "========================="
        
        # Check Redis
        if command -v redis-server >/dev/null 2>&1; then
          echo "  ‚úÖ Redis server - installed"
          if systemctl is-active redis-server >/dev/null 2>&1; then
            echo "    ‚úÖ Redis service - running"
          else
            echo "    ‚ö†Ô∏è  Redis service - not running"
          fi
        else
          echo "  ‚ùå Redis server - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS redis"
          INSTALL_REQUIRED=true
        fi
        
        # Check ImageMagick
        if command -v convert >/dev/null 2>&1; then
          IMAGEMAGICK_VERSION=$(convert --version | head -1)
          echo "  ‚úÖ ImageMagick - installed"
        else
          echo "  ‚ùå ImageMagick - NOT INSTALLED"
          MISSING_TOOLS="$MISSING_TOOLS imagemagick"
          INSTALL_REQUIRED=true
        fi
        
        echo ""
        echo "üìã AUDIT SUMMARY:"
        echo "================"
        
        if [ "$INSTALL_REQUIRED" = "true" ] || [ "{{ force_installation }}" = "true" ]; then
          echo "‚ùå INSTALLATION REQUIRED"
          echo ""
          if [ -n "$MISSING_PACKAGES" ]; then
            echo "Missing system packages:$MISSING_PACKAGES"
          fi
          if [ -n "$MISSING_TOOLS" ]; then
            echo "Missing/misconfigured tools:$MISSING_TOOLS"
          fi
          if [ "{{ force_installation }}" = "true" ]; then
            echo "Force installation flag is set - will reinstall all tools"
          fi
          
          echo "INSTALL_REQUIRED" > /tmp/tool_status
        else
          echo "‚úÖ ALL TOOLS ARE PROPERLY INSTALLED"
          echo "No installation required - server is ready for deployment"
          echo "TOOLS_READY" > /tmp/tool_status
        fi
        
        # Store missing items for installation
        echo "$MISSING_PACKAGES" > /tmp/missing_packages
        echo "$MISSING_TOOLS" > /tmp/missing_tools
      register: tool_audit
      become_user: "{{ deploy_user }}"

    - name: Display tool audit results
      debug:
        msg: "{{ tool_audit.stdout_lines }}"

    - name: Install missing system packages
      shell: |
        MISSING_PACKAGES=$(cat /tmp/missing_packages || echo "")
        FORCE_INSTALL="{{ force_installation }}"
        
        if [ -n "$MISSING_PACKAGES" ] || [ "$FORCE_INSTALL" = "true" ]; then
          echo "üì• INSTALLING SYSTEM PACKAGES..."
          echo "==============================="
          
          # Update package list
          echo "Updating package lists..."
          apt update
          
          # Install system packages
          echo "Installing packages: {{ system_packages | join(' ') }}"
          apt install -y {{ system_packages | join(' ') }}
          
          echo "‚úÖ System packages installation completed"
        else
          echo "‚è≠Ô∏è  Skipping system package installation - all packages present"
        fi

    - name: Setup Ruby environment (rbenv + Ruby + Bundler)
      shell: |
        MISSING_TOOLS=$(cat /tmp/missing_tools || echo "")
        FORCE_INSTALL="{{ force_installation }}"
        
        if echo "$MISSING_TOOLS" | grep -q "rbenv\\|ruby\\|bundler" || [ "$FORCE_INSTALL" = "true" ]; then
          echo "üíé SETTING UP RUBY ENVIRONMENT..."
          echo "================================="
          
          # Install rbenv if missing
          if [ ! -d "/home/{{ deploy_user }}/.rbenv" ] || [ "$FORCE_INSTALL" = "true" ]; then
            echo "Installing rbenv..."
            rm -rf /home/{{ deploy_user }}/.rbenv
            git clone https://github.com/rbenv/rbenv.git /home/{{ deploy_user }}/.rbenv
            git clone https://github.com/rbenv/ruby-build.git /home/{{ deploy_user }}/.rbenv/plugins/ruby-build
            
            # Add to bashrc if not already present
            if ! grep -q 'rbenv' /home/{{ deploy_user }}/.bashrc; then
              echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> /home/{{ deploy_user }}/.bashrc
              echo 'eval "$(rbenv init -)"' >> /home/{{ deploy_user }}/.bashrc
            fi
            
            chown -R {{ deploy_user }}:{{ deploy_user }} /home/{{ deploy_user }}/.rbenv
          fi
          
          # Install Ruby
          export PATH="/home/{{ deploy_user }}/.rbenv/bin:$PATH"
          eval "$(rbenv init -)"
          
          if ! rbenv versions | grep -q "{{ required_tools.ruby_version }}" || [ "$FORCE_INSTALL" = "true" ]; then
            echo "Installing Ruby {{ required_tools.ruby_version }}..."
            rbenv install {{ required_tools.ruby_version }}
            rbenv global {{ required_tools.ruby_version }}
            rbenv rehash
            
            # Install bundler
            echo "Installing Bundler {{ required_tools.bundler_version }}..."
            gem install bundler -v {{ required_tools.bundler_version }}
            rbenv rehash
            
            echo "‚úÖ Ruby {{ required_tools.ruby_version }} and Bundler {{ required_tools.bundler_version }} installed"
          else
            echo "‚úÖ Ruby environment already properly configured"
          fi
        else
          echo "‚è≠Ô∏è  Skipping Ruby installation - already properly configured"
        fi
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:{{ ansible_env.PATH }}"

    - name: Setup Node.js environment
      shell: |
        MISSING_TOOLS=$(cat /tmp/missing_tools || echo "")
        FORCE_INSTALL="{{ force_installation }}"
        
        if echo "$MISSING_TOOLS" | grep -q "nodejs\\|npm" || [ "$FORCE_INSTALL" = "true" ]; then
          echo "üü¢ SETTING UP NODE.JS ENVIRONMENT..."
          echo "==================================="
          
          # Install NodeSource repository and Node.js
          curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
          apt-get install -y nodejs
          
          # Verify installation
          NODE_VERSION=$(node --version)
          NPM_VERSION=$(npm --version)
          
          echo "‚úÖ Node.js installed: $NODE_VERSION"
          echo "‚úÖ npm installed: $NPM_VERSION"
        else
          echo "‚è≠Ô∏è  Skipping Node.js installation - already properly configured"
        fi

    - name: Configure PostgreSQL
      shell: |
        MISSING_TOOLS=$(cat /tmp/missing_tools || echo "")
        FORCE_INSTALL="{{ force_installation }}"
        
        if echo "$MISSING_TOOLS" | grep -q "postgresql" || [ "$FORCE_INSTALL" = "true" ]; then
          echo "üêò CONFIGURING POSTGRESQL..."
          echo "============================"
          
          # Start PostgreSQL service
          systemctl start postgresql
          systemctl enable postgresql
          
          # Create database user if doesn't exist
          sudo -u postgres psql -c "
            DO \\$\\$
            BEGIN
              IF NOT EXISTS (SELECT FROM pg_user WHERE usename = '{{ deploy_user }}') THEN
                CREATE USER {{ deploy_user }} WITH PASSWORD 'deploy123';
                ALTER USER {{ deploy_user }} CREATEDB;
                GRANT ALL PRIVILEGES ON DATABASE postgres TO {{ deploy_user }};
              END IF;
            END
            \\$\\$;
          " || echo "Database user configuration completed"
          
          echo "‚úÖ PostgreSQL configuration completed"
        else
          echo "‚è≠Ô∏è  Skipping PostgreSQL configuration - already properly configured"
        fi

    - name: Setup additional development tools
      shell: |
        MISSING_TOOLS=$(cat /tmp/missing_tools || echo "")
        FORCE_INSTALL="{{ force_installation }}"
        
        if echo "$MISSING_TOOLS" | grep -q "redis\\|imagemagick" || [ "$FORCE_INSTALL" = "true" ]; then
          echo "üõ†Ô∏è  SETTING UP ADDITIONAL TOOLS..."
          echo "=================================="
          
          # Start Redis if not running
          if command -v redis-server >/dev/null 2>&1; then
            systemctl start redis-server
            systemctl enable redis-server
            echo "‚úÖ Redis server started and enabled"
          fi
          
          echo "‚úÖ Additional tools configuration completed"
        else
          echo "‚è≠Ô∏è  Skipping additional tools setup - already properly configured"
        fi

    - name: Final tool verification
      shell: |
        echo "üîç FINAL TOOL VERIFICATION"
        echo "========================="
        echo ""
        
        # Verify all tools are now working
        echo "üõ†Ô∏è  FINAL TOOL STATUS:"
        echo "Ruby: $(ruby --version 2>/dev/null || echo '‚ùå Not available')"
        echo "Bundler: $(bundle --version 2>/dev/null || echo '‚ùå Not available')"
        echo "Node.js: $(node --version 2>/dev/null || echo '‚ùå Not available')"
        echo "npm: $(npm --version 2>/dev/null || echo '‚ùå Not available')"
        echo "PostgreSQL: $(psql --version 2>/dev/null || echo '‚ùå Not available')"
        echo "Python3: $(python3 --version 2>/dev/null || echo '‚ùå Not available')"
        echo "Redis: $(redis-server --version 2>/dev/null | head -1 || echo '‚ùå Not available')"
        echo "ImageMagick: $(convert --version 2>/dev/null | head -1 || echo '‚ùå Not available')"
        
        echo ""
        echo "üîå SERVICE STATUS:"
        echo "PostgreSQL: $(systemctl is-active postgresql 2>/dev/null || echo '‚ùå Not running')"
        echo "Redis: $(systemctl is-active redis-server 2>/dev/null || echo '‚ùå Not running')"
        
        echo ""
        
        # Final status check
        ALL_GOOD=true
        
        if ! command -v ruby >/dev/null 2>&1; then
          echo "‚ùå Ruby installation failed"
          ALL_GOOD=false
        fi
        
        if ! command -v bundle >/dev/null 2>&1; then
          echo "‚ùå Bundler installation failed"
          ALL_GOOD=false
        fi
        
        if ! command -v node >/dev/null 2>&1; then
          echo "‚ùå Node.js installation failed"
          ALL_GOOD=false
        fi
        
        if ! command -v psql >/dev/null 2>&1; then
          echo "‚ùå PostgreSQL client installation failed"
          ALL_GOOD=false
        fi
        
        if [ "$ALL_GOOD" = "true" ]; then
          echo "‚úÖ ALL TOOLS VERIFIED AND READY!"
          echo "Server is now prepared for Rails application deployment"
          echo "READY" > /tmp/final_status
        else
          echo "‚ùå SOME TOOLS FAILED TO INSTALL PROPERLY"
          echo "Please check the installation logs above"
          echo "FAILED" > /tmp/final_status
          exit 1
        fi
      become_user: "{{ deploy_user }}"
      ignore_errors: no

    - name: Display tool installation summary
      debug:
        msg: |
          üéâ TOOL INSTALLATION AND VERIFICATION COMPLETED! üéâ
          
          üõ†Ô∏è  Tools Successfully Installed/Verified:
          ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
          ‚úÖ Ruby {{ required_tools.ruby_version }} with rbenv
          ‚úÖ Bundler {{ required_tools.bundler_version }}
          ‚úÖ Node.js {{ required_tools.node_version }}
          ‚úÖ npm package manager
          ‚úÖ PostgreSQL {{ required_tools.postgres_version }}
          ‚úÖ PostgreSQL user '{{ deploy_user }}' configured
          ‚úÖ Python 3 with pip
          ‚úÖ Redis server
          ‚úÖ ImageMagick for image processing
          ‚úÖ All system dependencies and libraries
          
          üöÄ Server Status: READY FOR DEPLOYMENT
          ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
          The server now has all required tools installed and configured.
          Proceeding with application deployment...
EOF

                        # Find Ansible binary
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "‚úÖ Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        if [ -z "$ANSIBLE_BINARY" ]; then
                            echo "‚ùå Ansible not found!"
                            exit 1
                        fi
                        
                        ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                        
                        echo "üöÄ Running comprehensive tool verification and installation..."
                        echo "============================================================="
                        
                        # Run the tool verification and installation playbook
                        $ANSIBLE_PLAYBOOK_BINARY -i temp_ansible/inventories/${ENVIRONMENT}/hosts \
                            temp_ansible/playbooks/verify_and_install_tools.yml \
                            --extra-vars "force_tool_installation=${FORCE_TOOL_INSTALLATION}" \
                            -v
                        
                        if [ $? -eq 0 ]; then
                            echo ""
                            echo "‚úÖ TOOL VERIFICATION AND INSTALLATION COMPLETED SUCCESSFULLY!"
                            echo "Server is now ready for application deployment"
                            echo ""
                        else
                            echo ""
                            echo "‚ùå TOOL VERIFICATION/INSTALLATION FAILED!"
                            echo "Please check the logs above for errors"
                            exit 1
                        fi
                        
                        # Cleanup temporary files
                        rm -rf temp_ansible
                    '''
                }
            }
        }
        
        stage('Manual Approval') {
            steps {
                script {
                    def deploymentMessage = """
üöÄ READY TO DEPLOY: All tools verified/installed successfully!

Deploy to ${params.ENVIRONMENT} using Ansible?
"""
                    if (params.ENVIRONMENT == 'production') {
                        deploymentMessage = """
‚ö†Ô∏è PRODUCTION DEPLOYMENT ‚ö†Ô∏è

‚úÖ All tools verified and ready
üéØ Target: PRODUCTION environment

Are you sure you want to deploy to PRODUCTION?

Build: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}
Method: Ansible automation
"""
                    }
                    
                    def approver = input message: deploymentMessage,
                                        ok: "Deploy to ${params.ENVIRONMENT}",
                                        submitterParameter: 'APPROVER'
                    
                    env.DEPLOYMENT_APPROVER = approver ?: 'unknown'
                    
                    echo "Deployment approved by: ${env.DEPLOYMENT_APPROVER}"
                    echo "Deploying to: ${params.ENVIRONMENT}"
                    echo "Build to deploy: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                    echo "Tool check: ${params.SKIP_TOOL_CHECK ? 'Skipped' : 'Completed'}"
                }
            }
        }
        
        stage('Download Artifact') {
            steps {
                script {
                    cleanWs()
                    
                    def buildNumber = params.BUILD_NUMBER_TO_DEPLOY ?: ''
                    def ciJobName = 'hello-rails'
                    
                    echo "Downloading artifact from: ${ciJobName}"
                    
                    try {
                        if (buildNumber) {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'SpecificBuildSelector', buildNumber: buildNumber],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        } else {
                            step([$class: 'CopyArtifact',
                                  projectName: ciJobName,
                                  selector: [$class: 'StatusBuildSelector', stable: false],
                                  filter: 'hello-world-app-*.tar.gz',
                                  fingerprintArtifacts: true])
                        }
                        
                        sh '''
                            if ls hello-world-app-*.tar.gz 1> /dev/null 2>&1; then
                                echo "‚úÖ Artifact files found:"
                                ls -la hello-world-app-*.tar.gz
                            else
                                echo "‚ùå No artifact files found!"
                                exit 1
                            fi
                        '''
                        
                    } catch (Exception e) {
                        error("Failed to download artifact: ${e.message}")
                    }
                }
            }
        }
        
        stage('Setup Ansible Environment') {
            steps {
                script {
                    sh '''
                        # Debug current location
                        echo "=== Debug Information ==="
                        echo "Current directory: $(pwd)"
                        echo "Files in current directory:"
                        ls -la
                        
                        # Find Ansible binary directly
                        echo "Locating Ansible installation..."
                        
                        # Check multiple possible locations
                        ANSIBLE_BINARY=""
                        POSSIBLE_PATHS=(
                            "/usr/local/bin/ansible"
                            "/opt/homebrew/bin/ansible"
                            "$HOME/Library/Python/3.9/bin/ansible"
                            "$HOME/.local/bin/ansible"
                        )
                        
                        for path in "${POSSIBLE_PATHS[@]}"; do
                            if [ -f "$path" ]; then
                                ANSIBLE_BINARY="$path"
                                echo "‚úÖ Found Ansible at: $path"
                                break
                            fi
                        done
                        
                        # Test Ansible with direct path
                        echo "Testing Ansible..."
                        $ANSIBLE_BINARY --version
                        
                        # Store the path for later stages
                        echo "$ANSIBLE_BINARY" > /tmp/ansible_path
                        echo "ANSIBLE_DIR=$(dirname $ANSIBLE_BINARY)" > /tmp/ansible_env
                        
                        # Create Ansible structure for Rails deployment
                        echo "Creating Ansible structure for Rails deployment..."
                        mkdir -p ansible/{inventories,playbooks}
                        mkdir -p ansible/inventories/staging
                        mkdir -p ansible/inventories/production
                        
                        # Create inventory file for staging
                        cat > ansible/inventories/staging/hosts << 'EOF'
[webservers]
staging-server ansible_host=3.237.64.25 ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=staging
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create inventory file for production
                        cat > ansible/inventories/production/hosts << 'EOF'
[webservers]
production-server ansible_host=YOUR_PROD_IP ansible_user=deploy

[all:vars]
ansible_ssh_private_key_file=~/.ssh/deploy_key
rails_env=production
app_name=hello-world-app
deploy_user=deploy
deploy_path=/var/www/hello-world-app
EOF

                        # Create Rails deployment playbook (tools are already installed)
                        cat > ansible/playbooks/deploy.yml << 'EOF'
---
- name: Deploy Rails Application (Tools Pre-Verified)
  hosts: webservers
  become: yes
  vars:
    app_archive_path: "/tmp/{{ app_name }}-{{ build_number | default('latest') }}.tar.gz"
  
  tasks:
    - name: Upload artifact to server
      shell: |
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no "{{ local_artifact_path }}" deploy@{{ ansible_host }}:/tmp/{{ app_name }}-{{ build_number }}.tar.gz
      delegate_to: localhost
      become: no

    - name: Create deployment directories
      file:
        path: "{{ deploy_path }}/{{ rails_env }}/current"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0755'

    - name: Extract application
      unarchive:
        src: "{{ app_archive_path }}"
        dest: "{{ deploy_path }}/{{ rails_env }}/current"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        remote_src: yes

    - name: Install Rails dependencies
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        echo "üì¶ Installing Rails application dependencies..."
        
        # Set up Ruby environment (tools are pre-installed)
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        
        # Install Ruby gems
        bundle install --deployment --without development test
        
        # Install Node.js dependencies if package.json exists
        if [ -f "package.json" ]; then
          echo "üì¶ Installing Node.js dependencies..."
          npm install --production
        fi
        
        echo "‚úÖ Application dependencies installed"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"

    - name: Rails database operations
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo "üóÑÔ∏è  Performing Rails database operations..."
        
        # Create database
        echo "=== RAILS_ENV={{ rails_env }} bundle exec rake db:create ==="
        RAILS_ENV={{ rails_env }} bundle exec rake db:create 2>/dev/null || echo "Database already exists"
        
        # Run migrations
        echo "=== RAILS_ENV={{ rails_env }} bundle exec rake db:migrate ==="
        RAILS_ENV={{ rails_env }} bundle exec rake db:migrate
        
        # Precompile assets
        echo "=== RAILS_ENV={{ rails_env }} bundle exec rake assets:precompile ==="
        RAILS_ENV={{ rails_env }} bundle exec rake assets:precompile
        
        echo "‚úÖ Rails database operations completed"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"
        RAILS_ENV: "{{ rails_env }}"

    - name: Stop existing servers
      shell: |
        pkill -f 'python.*http.server' || true
        pkill -f 'rails server' || true
        pkill -f 'puma' || true
        sleep 3
      become_user: "{{ deploy_user }}"
      ignore_errors: yes

    - name: Start Rails application
      shell: |
        cd {{ deploy_path }}/{{ rails_env }}/current
        
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo "üöÄ Starting Rails application..."
        nohup bundle exec rails server -e {{ rails_env }} -p 3000 -b 0.0.0.0 > log/rails.log 2>&1 &
        echo $! > tmp/pids/rails.pid
        
        sleep 10
        echo "‚úÖ Rails application started"
      become_user: "{{ deploy_user }}"
      environment:
        PATH: "/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:{{ ansible_env.PATH }}"
        RAILS_ENV: "{{ rails_env }}"

    - name: Verify deployment
      shell: |
        echo "üîç DEPLOYMENT VERIFICATION"
        echo "========================="
        
        # Check server status
        if ps aux | grep -v grep | grep 'rails server'; then
          echo "‚úÖ Rails server is running"
        else
          echo "‚ùå Rails server not running"
        fi
        
        if netstat -tlnp | grep :3000; then
          echo "‚úÖ Port 3000 is listening"
        else
          echo "‚ùå Port 3000 not listening"
        fi
        
        # Check database connectivity
        cd {{ deploy_path }}/{{ rails_env }}/current
        export PATH="/home/{{ deploy_user }}/.rbenv/bin:/home/{{ deploy_user }}/.rbenv/shims:$PATH"
        eval "$(rbenv init -)"
        export RAILS_ENV={{ rails_env }}
        
        echo ""
        echo "üóÑÔ∏è  DATABASE STATUS:"
        RAILS_ENV={{ rails_env }} bundle exec rails runner "
          begin
            ActiveRecord::Base.connection.active?
            puts '‚úÖ Database connection: Active'
            puts 'üìä Total tables: ' + ActiveRecord::Base.connection.tables.count.to_s
          rescue => e
            puts '‚ùå Database connection failed: ' + e.message
          end
        " 2>/dev/null || echo "Could not test database connection"
        
        echo ""
        echo "üìã DEPLOYMENT SUMMARY:"
        echo "‚úÖ Rails application deployed successfully"
        echo "‚úÖ Database operations completed"
        echo "‚úÖ Rails server started and verified"
        echo "üåê Application URL: http://{{ ansible_host }}:3000"
      become_user: "{{ deploy_user }}"
      ignore_errors: yes

    - name: Display deployment success
      debug:
        msg: |
          üéâ RAILS DEPLOYMENT COMPLETED SUCCESSFULLY! üéâ
          
          üõ†Ô∏è  Pre-Deployment Tool Verification: ‚úÖ PASSED
          üì¶ Application Deployment: ‚úÖ COMPLETED
          üóÑÔ∏è  Database Operations: ‚úÖ COMPLETED
          üöÄ Rails Server: ‚úÖ STARTED
          
          üîó Access Information:
          ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
          URL: http://{{ ansible_host }}:3000
          SSH: ssh {{ deploy_user }}@{{ ansible_host }}
          Logs: ssh {{ deploy_user }}@{{ ansible_host }} 'tail -f {{ deploy_path }}/{{ rails_env }}/current/log/rails.log'
EOF
                        
                        echo "‚úÖ Ansible structure for Rails deployment created"
                    '''
                }
            }
        }
        
        stage('Prepare Deployment') {
            steps {
                script {
                    sh '''
                        # Get artifact info
                        ARTIFACT_FILE=$(ls hello-world-app-*.tar.gz | head -1)
                        BUILD_NUM=$(echo $ARTIFACT_FILE | sed 's/hello-world-app-//; s/.tar.gz//')
                        
                        echo "Artifact: $ARTIFACT_FILE"
                        echo "Build number: $BUILD_NUM"
                        
                        # Copy artifact to /tmp for local access
                        cp $ARTIFACT_FILE /tmp/hello-world-app-${BUILD_NUM}.tar.gz
                        
                        # Also keep the artifact in workspace for SCP transfer
                        echo "Artifact location: $(pwd)/$ARTIFACT_FILE"
                        
                        # Create ansible variables file
                        cat > ansible/extra_vars.yml << EOF
build_number: ${BUILD_NUM}
app_archive_path: /tmp/hello-world-app-${BUILD_NUM}.tar.gz
local_artifact_path: $(pwd)/${ARTIFACT_FILE}
environment: ${ENVIRONMENT}
deployed_by: ${DEPLOYMENT_APPROVER}
deployed_at: $(date)
EOF
                        
                        echo "=== Deployment Variables ==="
                        cat ansible/extra_vars.yml
                    '''
                }
            }
        }
        
        stage('Test Ansible Connectivity') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            # Load Ansible path
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            
                            echo "Testing Ansible connectivity..."
                            echo "Using Ansible binary: $ANSIBLE_BINARY"
                            echo "Using inventory: inventories/${ENVIRONMENT}/hosts"
                            
                            # Test ping with direct binary path
                            $ANSIBLE_BINARY -i inventories/${ENVIRONMENT}/hosts webservers -m ping
                            
                            if [ $? -eq 0 ]; then
                                echo "‚úÖ Ansible connectivity test passed"
                            else
                                echo "‚ùå Ansible connectivity test failed"
                                echo "Debugging information:"
                                echo "Current directory: $(pwd)"
                                echo "Inventory file contents:"
                                cat inventories/${ENVIRONMENT}/hosts
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deploy Rails Application') {
            steps {
                script {
                    dir('ansible') {
                        sh '''
                            # Load Ansible path
                            source /tmp/ansible_env
                            ANSIBLE_BINARY=$(cat /tmp/ansible_path)
                            ANSIBLE_PLAYBOOK_BINARY="$(dirname $ANSIBLE_BINARY)/ansible-playbook"
                            
                            echo "üöÄ Starting Rails application deployment..."
                            echo "===========================================" 
                            echo "Environment: ${ENVIRONMENT}"
                            echo "Using binary: $ANSIBLE_PLAYBOOK_BINARY"
                            echo "Deploying artifact: $(cat extra_vars.yml | grep app_archive_path)"
                            echo "Tools: ‚úÖ Pre-verified and ready"
                            echo ""
                            
                            # Run Rails deployment playbook
                            $ANSIBLE_PLAYBOOK_BINARY -i inventories/${ENVIRONMENT}/hosts playbooks/deploy.yml \
                                --extra-vars @extra_vars.yml \
                                -v
                            
                            if [ $? -eq 0 ]; then
                                echo ""
                                echo "‚úÖ RAILS APPLICATION DEPLOYMENT COMPLETED SUCCESSFULLY!"
                                echo "All tools were pre-verified, deployment proceeded smoothly"
                            else
                                echo ""
                                echo "‚ùå Rails application deployment failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Post-Deployment Verification') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "üè• Performing comprehensive post-deployment verification..."
                            
                            # Wait for application to start
                            sleep 20
                            
                            # Health check with retries
                            MAX_RETRIES=15
                            RETRY_COUNT=0
                            
                            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                                echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
                                
                                if curl -f -s -o /dev/null http://${EC2_HOST}:3000/health || curl -f -s -o /dev/null http://${EC2_HOST}:3000/; then
                                    echo "‚úÖ Application is responding!"
                                    
                                    # Additional verification
                                    RESPONSE=$(curl -s http://${EC2_HOST}:3000 | head -c 200)
                                    if echo "$RESPONSE" | grep -i "rails\\|application\\|welcome" > /dev/null; then
                                        echo "‚úÖ Rails application is serving content correctly"
                                    fi
                                    break
                                else
                                    echo "‚è≥ Application not ready, retrying in 10 seconds..."
                                    sleep 10
                                    RETRY_COUNT=$((RETRY_COUNT + 1))
                                fi
                            done
                            
                            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                                echo "‚ùå Health check failed after $MAX_RETRIES attempts"
                                echo "üîß Check application logs: ssh deploy@${EC2_HOST} 'tail -50 /var/www/hello-world-app/${ENVIRONMENT}/current/log/rails.log'"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deployment Summary') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "
üéâ COMPREHENSIVE DEPLOYMENT WITH TOOL VERIFICATION COMPLETED! üéâ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä Deployment Details:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Environment: ${ENVIRONMENT}
Server: ${EC2_HOST}
Approved by: ${DEPLOYMENT_APPROVER}
Build: ${BUILD_NUMBER_TO_DEPLOY:-latest}
Method: Pre-verified tools + Ansible Rails deployment
Application URL: http://${EC2_HOST}:3000
Deployment time: $(date)

üõ†Ô∏è  Pre-Deployment Tool Verification:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
$([ '${SKIP_TOOL_CHECK}' = 'true' ] && echo '‚è≠Ô∏è  SKIPPED - Tool check bypassed' || echo '‚úÖ COMPLETED - All tools verified/installed')
‚úÖ Ruby 3.1.3 with rbenv
‚úÖ Bundler 2.3.0
‚úÖ Node.js 18.x with npm
‚úÖ PostgreSQL 14 with configured user
‚úÖ Python 3 with pip
‚úÖ Redis server
‚úÖ ImageMagick and development libraries
‚úÖ All system dependencies

üöÄ Rails Application Deployment:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ Application artifact deployed
‚úÖ Ruby gems installed (bundle install)
‚úÖ Node.js dependencies installed (npm install)
‚úÖ RAILS_ENV=${ENVIRONMENT} bundle exec rake db:create
‚úÖ RAILS_ENV=${ENVIRONMENT} bundle exec rake db:migrate
‚úÖ RAILS_ENV=${ENVIRONMENT} bundle exec rake assets:precompile
‚úÖ Rails server started and verified
‚úÖ Database connectivity confirmed
‚úÖ HTTP health check passed

üîó Access Information:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üåê Application URL: http://${EC2_HOST}:3000
üîß SSH Access: ssh deploy@${EC2_HOST}
üìã Application Logs: ssh deploy@${EC2_HOST} 'tail -f /var/www/hello-world-app/${ENVIRONMENT}/current/log/rails.log'
üîÑ Restart Rails: ssh deploy@${EC2_HOST} 'cd /var/www/hello-world-app/${ENVIRONMENT}/current && bundle exec rails server -e ${ENVIRONMENT} -d'

üí° Pipeline Features:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîç Pre-deployment tool verification and auto-installation
‚ö° Skip tool check option for verified servers
üîÑ Force reinstallation option for troubleshooting
üìä Comprehensive tool audit and verification
‚úÖ Production-ready Rails deployment pipeline
üõ°Ô∏è  Database operations with proper environment handling
                            "
                        '''
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "‚úÖ Comprehensive deployment with tool verification to ${params.ENVIRONMENT} completed successfully!"
            
            script {
                try {
                    withCredentials([
                        string(credentialsId: 'slack-webhook-url', variable: 'SLACK_WEBHOOK')
                    ]) {
                        sh '''
                            curl -X POST -H 'Content-type: application/json' \
                                --data '{"text":"‚úÖ Tool-Verified Rails Deployment Success: '${APP_NAME}' to '${ENVIRONMENT}' - Build #'${BUILD_NUMBER}' (by '${DEPLOYMENT_APPROVER}') - All tools pre-verified and Rails deployed successfully"}' \
                                $SLACK_WEBHOOK
                        '''
                    }
                } catch (Exception e) {
                    echo "Notification failed: ${e.message}"
                }
            }
        }
        
        failure {
            echo "‚ùå Deployment with tool verification to ${params.ENVIRONMENT} failed!"
            
            script {
                try {
                    withCredentials([
                        string(credentialsId: 'slack-webhook-url', variable: 'SLACK_WEBHOOK')
                    ]) {
                        sh '''
                            curl -X POST -H 'Content-type: application/json' \
                                --data '{"text":"‚ùå Tool-Verified Rails Deployment Failed: '${APP_NAME}' to '${ENVIRONMENT}' - Build #'${BUILD_NUMBER}' (by '${DEPLOYMENT_APPROVER}') - Check tool verification or deployment logs"}' \
                                $SLACK_WEBHOOK
                        '''
                    }
                } catch (Exception e) {
                    echo "Failed notification: ${e.message}"
                }
            }
        }
        
        always {
            script {
                sh '''
                    rm -f hello-world-app-*.tar.gz
                    rm -f ansible/extra_vars.yml
                    rm -rf temp_ansible
                '''
            }
            cleanWs()
        }
    }
}