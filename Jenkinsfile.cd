pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['staging', 'production'],
            description: 'Select deployment environment'
        )
        string(
            name: 'BUILD_NUMBER_TO_DEPLOY',
            defaultValue: '',
            description: 'Build number from CI pipeline to deploy (leave empty for latest)'
        )
    }
    
    environment {
        APP_NAME = 'hello-world-app'
        DEPLOY_USER = 'deploy'
        DEPLOY_PATH = '/var/www/hello-world-app'
    }
    
    stages {
        stage('Manual Approval') {
            steps {
                script {
                    def deploymentMessage = "Deploy to ${params.ENVIRONMENT}?"
                    if (params.ENVIRONMENT == 'production') {
                        deploymentMessage = "âš ï¸ PRODUCTION DEPLOYMENT âš ï¸\n\nAre you sure you want to deploy to PRODUCTION?\n\nBuild: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                    }
                    
                    def approver = input message: deploymentMessage,
                                        ok: "Deploy to ${params.ENVIRONMENT}",
                                        submitterParameter: 'APPROVER'
                    
                    env.DEPLOYMENT_APPROVER = approver ?: 'unknown'
                    
                    echo "Deployment approved by: ${env.DEPLOYMENT_APPROVER}"
                    echo "Deploying to: ${params.ENVIRONMENT}"
                    echo "Build to deploy: ${params.BUILD_NUMBER_TO_DEPLOY ?: 'latest'}"
                }
            }
        }
        
        stage('Download Artifact') {
            steps {
                script {
                    cleanWs()
                    
                    def buildNumber = params.BUILD_NUMBER_TO_DEPLOY ?: ''
                    def ciJobName = 'hello-rails'  // This should match your CI job name
                    
                    echo "Downloading artifact from: ${ciJobName}"
                    echo "Build number: ${buildNumber ?: 'latest successful'}"
                    
                    try {
                        if (buildNumber) {
                            copyArtifacts(
                                projectName: ciJobName,
                                selector: specific(buildNumber),
                                filter: 'hello-world-app-*.tar.gz',
                                fingerprintArtifacts: true
                            )
                            echo "âœ… Artifact downloaded from build ${buildNumber}"
                        } else {
                            copyArtifacts(
                                projectName: ciJobName,
                                selector: lastSuccessful(),
                                filter: 'hello-world-app-*.tar.gz',
                                fingerprintArtifacts: true
                            )
                            echo "âœ… Artifact downloaded from latest successful build"
                        }
                        
                        // Verify artifact was downloaded
                        sh '''
                            if ls hello-world-app-*.tar.gz 1> /dev/null 2>&1; then
                                echo "âœ… Artifact files found:"
                                ls -la hello-world-app-*.tar.gz
                            else
                                echo "âŒ No artifact files found!"
                                echo "Available files:"
                                ls -la
                                exit 1
                            fi
                        '''
                        
                    } catch (Exception e) {
                        echo "âŒ Failed to download artifact: ${e.message}"
                        echo "Make sure:"
                        echo "1. Copy Artifact Plugin is installed"
                        echo "2. CI job name is correct: ${ciJobName}"
                        echo "3. CI job has successfully created artifacts"
                        error("Artifact download failed: ${e.message}")
                    }
                }
            }
        }
        
        stage('Deploy to EC2') {
            steps {
                script {
                    withCredentials([
                        sshUserPrivateKey(
                            credentialsId: 'ec2-ssh-key',
                            keyFileVariable: 'SSH_KEY',
                            usernameVariable: 'SSH_USER'
                        ),
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST'),
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-database-url", variable: 'DATABASE_URL')
                    ]) {
                        sh '''
                            # Get artifact info
                            ARTIFACT_FILE=$(ls hello-world-app-*.tar.gz | head -1)
                            echo "Deploying: $ARTIFACT_FILE"
                            
                            # Create release directory name
                            RELEASE_DIR="${DEPLOY_PATH}/${ENVIRONMENT}/releases/$(date +%Y%m%d%H%M%S)"
                            CURRENT_DIR="${DEPLOY_PATH}/${ENVIRONMENT}/current"
                            
                            echo "Release directory: $RELEASE_DIR"
                            echo "Current directory: $CURRENT_DIR"
                            
                            # Create directories on EC2
                            ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$EC2_HOST "
                                sudo mkdir -p $RELEASE_DIR
                                sudo mkdir -p ${DEPLOY_PATH}/${ENVIRONMENT}/shared/{log,tmp,config}
                                sudo chown -R ${DEPLOY_USER}:${DEPLOY_USER} ${DEPLOY_PATH}
                            "
                            
                            # Upload and extract application
                            scp -i $SSH_KEY -o StrictHostKeyChecking=no $ARTIFACT_FILE $SSH_USER@$EC2_HOST:/tmp/
                            
                            ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$EC2_HOST "
                                cd $RELEASE_DIR
                                tar -xzf /tmp/$ARTIFACT_FILE --strip-components=1
                                
                                # Generate Rails secret key
                                export PATH=\"\\$HOME/.rbenv/bin:\\$PATH\"
                                eval \"\\$(rbenv init -)\"
                                GENERATED_SECRET=\\$(bundle exec rails secret)
                                
                                # Create environment file
                                cat > .env.${ENVIRONMENT} << EOF
RAILS_ENV=${ENVIRONMENT}
DATABASE_URL=${DATABASE_URL}
SECRET_KEY_BASE=\\$GENERATED_SECRET
RAILS_LOG_TO_STDOUT=true
RAILS_SERVE_STATIC_FILES=true
EOF
                                
                                echo \"Generated new Rails secret key for ${ENVIRONMENT}\"
                                
                                # Install gems
                                bundle install --deployment --without development test
                                
                                # Create symlinks
                                ln -sfn ${DEPLOY_PATH}/${ENVIRONMENT}/shared/log log
                                ln -sfn ${DEPLOY_PATH}/${ENVIRONMENT}/shared/tmp tmp
                                
                                # Run database tasks
                                source .env.${ENVIRONMENT}
                                bundle exec rake db:create db:migrate
                                
                                # Precompile assets
                                bundle exec rake assets:precompile
                                
                                # Update current symlink
                                ln -sfn $RELEASE_DIR $CURRENT_DIR
                                
                                # Restart application
                                pkill -f 'rails server' || true
                                cd $CURRENT_DIR
                                nohup bundle exec rails server -e ${ENVIRONMENT} -p 3000 > log/rails.log 2>&1 &
                                
                                # Cleanup old releases (keep last 5)
                                cd ${DEPLOY_PATH}/${ENVIRONMENT}/releases
                                ls -t | tail -n +6 | xargs -r rm -rf
                                
                                echo 'Deployment completed successfully!'
                            "
                            
                            # Clean up local artifact
                            rm -f /tmp/$ARTIFACT_FILE
                        '''
                    }
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "Waiting for application to start..."
                            sleep 20
                            
                            # Check if application is responding
                            MAX_RETRIES=10
                            RETRY_COUNT=0
                            
                            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                                echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
                                
                                if curl -f -s -o /dev/null http://${EC2_HOST}:3000/health || curl -f -s -o /dev/null http://${EC2_HOST}:3000/; then
                                    echo "âœ… Application is responding!"
                                    break
                                else
                                    echo "â³ Application not ready, retrying in 10 seconds..."
                                    sleep 10
                                    RETRY_COUNT=$((RETRY_COUNT + 1))
                                fi
                            done
                            
                            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                                echo "âŒ Health check failed after $MAX_RETRIES attempts"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Deployment Summary') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "
ðŸŽ‰ Deployment Summary:
================================
Environment: ${ENVIRONMENT}
Server: ${EC2_HOST}
Approved by: ${DEPLOYMENT_APPROVER}
Build: ${BUILD_NUMBER_TO_DEPLOY:-latest}
Application URL: http://${EC2_HOST}:3000
Deployment time: $(date)
================================
                            "
                        '''
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "âœ… Deployment to ${params.ENVIRONMENT} completed successfully!"
            
            // Optional: Send success notification
            script {
                try {
                    withCredentials([
                        string(credentialsId: 'slack-webhook-url', variable: 'SLACK_WEBHOOK')
                    ]) {
                        sh '''
                            curl -X POST -H 'Content-type: application/json' \
                                --data '{"text":"âœ… Deployment Success: '${APP_NAME}' to '${ENVIRONMENT}' - Build #'${BUILD_NUMBER}' (by '${DEPLOYMENT_APPROVER}')"}' \
                                $SLACK_WEBHOOK
                        '''
                    }
                } catch (Exception e) {
                    echo "Notification failed: ${e.message}"
                }
            }
        }
        
        failure {
            echo "âŒ Deployment to ${params.ENVIRONMENT} failed!"
            
            // Optional: Rollback logic
            script {
                try {
                    withCredentials([
                        sshUserPrivateKey(
                            credentialsId: 'ec2-ssh-key',
                            keyFileVariable: 'SSH_KEY',
                            usernameVariable: 'SSH_USER'
                        ),
                        string(credentialsId: "ec2-${params.ENVIRONMENT}-host", variable: 'EC2_HOST')
                    ]) {
                        sh '''
                            echo "Attempting rollback to previous release..."
                            ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$EC2_HOST "
                                cd ${DEPLOY_PATH}/${ENVIRONMENT}/releases
                                PREVIOUS_RELEASE=\\$(ls -t | sed -n 2p)
                                if [ -n \"\\$PREVIOUS_RELEASE\" ]; then
                                    ln -sfn ${DEPLOY_PATH}/${ENVIRONMENT}/releases/\\$PREVIOUS_RELEASE ${DEPLOY_PATH}/${ENVIRONMENT}/current
                                    echo \"Rolled back to: \\$PREVIOUS_RELEASE\"
                                    
                                    # Restart application
                                    cd ${DEPLOY_PATH}/${ENVIRONMENT}/current
                                    export PATH=\"\\$HOME/.rbenv/bin:\\$PATH\"
                                    eval \"\\$(rbenv init -)\"
                                    source .env.${ENVIRONMENT}
                                    pkill -f 'rails server' || true
                                    nohup bundle exec rails server -e ${ENVIRONMENT} -p 3000 > log/rails.log 2>&1 &
                                else
                                    echo \"No previous release found for rollback\"
                                fi
                            "
                        '''
                    }
                } catch (Exception e) {
                    echo "Rollback failed: ${e.message}"
                }
            }
        }
        
        always {
            cleanWs()
        }
    }
}